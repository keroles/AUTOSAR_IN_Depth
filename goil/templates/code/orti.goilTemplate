%
#
# Generate the system calls according to the configuration
# FIXME : Move to root and remove in api.goilTemplate
#
let APIMAP := mapof APICONFIG by NAME
let APIUSED := @()

let APIUSED += APIMAP["os"]
let APIUSED += APIMAP["interrupt"]

#
# Check and generate system calls
#
if [TRANSACTION length] > 0 then
let APIUSED += APIMAP["stm"]
end if
if [TASKS length] > 0 then
  let APIUSED += APIMAP["task"]
end if
if [RESOURCES length] > 0 | OS::USERESSCHEDULER then
  let APIUSED += APIMAP["resource"]
end if
if [TASKS length] > 0  & [EVENTS length] > 0 then
  let APIUSED += APIMAP["event"]
end if
if [ALARMS length] > 0 then
  let APIUSED += APIMAP["alarm"]
end if
if [MESSAGES length] > 0 then
  let APIUSED += APIMAP["message"]
end if

if exists SEMAPHORE then
  if [SEMAPHORE length] > 0 then
    let APIUSED += APIMAP["semaphore"]
  end if
end if

# AUTOSAR
if OS::SCALABILITYCLASS > 0 then
  let APIUSED += APIMAP["counter"]
  let APIUSED += APIMAP["scheduletables"]
  let APIUSED += APIMAP["isrs"]
end if
if OS::SCALABILITYCLASS > 2 then
  let APIUSED += APIMAP["applications"]
end if
if OS::SCALABILITYCLASS == 2 | OS::SCALABILITYCLASS == 4 then
  let APIUSED += APIMAP["globaltime"]
end if

# Multicore
if OS::NUMBER_OF_CORES > 1 then
  let APIUSED += APIMAP["multicore"]

  if [SPINLOCK length] > 0 then
    let APIUSED += APIMAP["spinlock"]
  end if

end if

# IOC
if ioc_queued_count > 0 then
  let APIUSED += APIMAP["ioc_queued"]
end if
if ioc_unqueued_count > 0 then
  let APIUSED += APIMAP["ioc_unqueued"]
end if

let listOfApiFunc := @( )
foreach api_sec in APIUSED do
  foreach api_func in api_sec::SYSCALL do
    let listOfApiFunc += api_func
  end foreach
end foreach
sort listOfApiFunc by CALLABLE_BY_ISR1 >

%
/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * TPL ORTI structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

VERSION
{
  KOIL = "2.2";
  OSSEMANTICS = "ORTI", "2.2";
};

/* ----------------------------------------------------------------------------
 * Implementation
 */
IMPLEMENTATION Trampoline_ORTI
{
  OS
  {%
if OS::NUMBER_OF_CORES > 1 then%
    /* In accordance with Lauterbach's ORTI_SMP_Proposal_v4 extension */
    CTYPE "int" vs_SMP_NUMCPU, "Number of CPUs";%
end if%
    CTYPE VALID[];
    ENUM [
%
foreach proc in PROCESSES do
  if proc::KIND == "Task" then
%      "% !proc::NAME %" = % !INDEX %,
%
  else
%      "X" = % !INDEX %,
%
  end if
end foreach

if OS::NUMBER_OF_CORES > 1 then
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%      "idle_% !core_id %" = % !([PROCESSES length] + core_id)
  between %,
%
  end loop
else
%      "idle" = % ![PROCESSES length]
end if
%
    ] RUNNINGTASK[];
    ENUM [
%
foreach proc in PROCESSES do
  if proc::KIND == "ISR" then
%      "% !proc::NAME %" = % !INDEX %,
%
  else
%      "X" = % !INDEX %,
%
  end if
end foreach

if OS::NUMBER_OF_CORES > 1 then
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%      "X" = % !([PROCESSES length] + core_id)
  between %,
%
  end loop
else
%      "X" = % ![PROCESSES length]
end if
%
    ] RUNNINGISR2[];
    CTYPE RUNNINGTASKPRIORITY[];
    TOTRACE ENUM [
%
foreach api in listOfApiFunc do
%      "% !api::NAME %" = % !(INDEX * 2)
between %,
%
end foreach
%
    ] SERVICETRACE[];
    ENUM [
      "E_OK"                       =  0,
      "E_OS_ACCESS"                =  1,
      "E_OS_CALLEVEL"              =  2,
      "E_OS_ID"                    =  3,
      "E_OS_LIMIT"                 =  4,
      "E_OS_NOFUNC"                =  5,
      "E_OS_RESOURCE"              =  6,
      "E_OS_STATE"                 =  7,
      "E_OS_VALUE"                 =  8,
      "E_NOT_OK"                   =  9,
      "E_COM_ID"                   = 10,
      "E_COM_LENGTH"               = 11,
      "E_COM_LIMIT"                = 12,
      "E_COM_NOMSG"                = 13,
      "E_COM_FILTERDOUR"           = 14,
      "E_OS_SERVICEID"             = 16,
      "E_OS_ILLEGAL_ADDRESS"       = 17,
      "E_OS_MISSINGEND"            = 18,
      "E_OS_DISABLEDINT"           = 19,
      "E_OS_STACKFAULT"            = 20,
      "E_OS_PROTECTION_MEMORY"     = 21,
      "E_OS_PROTECTION_TIME"       = 22,
      "E_OS_PROTECTION_ARRIVAL"    = 23,
      "E_OS_PROTECTION_LOCKED"     = 24,
      "E_OS_PROTECTION_EXCEPTION"  = 25,
      "E_OS_INTERFERENCE_DEADLOCK" = 26,
      "E_OS_NESTING_DEADLOCK"      = 27,
      "E_OS_SPINLOCK"              = 28,
      "E_OS_LOST_DATA"             = 29,
      "E_OS_NO_DATA"               = 30
    ] LASTERROR[]; /* FIXME : Not generated */
    ENUM [
      "NOAPPMODE" = "-1",%
foreach appmode in APPMODE do
  if (appmode::DEFAULT) | ([APPMODE length] == 1) then%
      "OSDEFAULTAPPMODE" = "% !INDEX %"%
  else %
      "% !appmode::NAME %" = "% !INDEX %"%
  end if
between %,%
end foreach
  %
    ] CURRENTAPPMODE[];%
if OS::NUMBER_OF_CORES > 1 & [SPINLOCK length] > 0 then%
    CTYPE _vs_HELD_SPINLOCKS[];
    ENUM [
      "NONE" = "-1",%
foreach spinlock in SPINLOCK do%
      "% !spinlock::NAME %" = "% !INDEX %"%
between %,%
end foreach
  %
    ] _vs_LAST_TAKEN_SPINLOCK[];%
end if%
  };
  /* XXX : OS is replicated to display all cores' informations in multicore */
  _vs_OS
  {%
if OS::NUMBER_OF_CORES > 1 then%
    /* In accordance with Lauterbach's ORTI_SMP_Proposal_v4 extension */
    CTYPE "int" vs_SMP_NUMCPU, "Number of CPUs";%
end if%
    CTYPE VALID[];
    ENUM [
%
foreach proc in PROCESSES do
  if proc::KIND == "Task" then
%      "% !proc::NAME %" = % !INDEX %,
%
  else
%      "X" = % !INDEX %,
%
  end if
end foreach

if OS::NUMBER_OF_CORES > 1 then
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%      "idle_% !core_id %" = % !([PROCESSES length] + core_id)
  between %,
%
  end loop
else
%      "idle" = % ![PROCESSES length]
end if
%
    ] RUNNINGTASK[];
    ENUM [
%
foreach proc in PROCESSES do
  if proc::KIND == "ISR" then
%      "% !proc::NAME %" = % !INDEX %,
%
  else
%      "X" = % !INDEX %,
%
  end if
end foreach

if OS::NUMBER_OF_CORES > 1 then
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%      "X" = % !([PROCESSES length] + core_id)
  between %,
%
  end loop
else
%      "X" = % ![PROCESSES length]
end if
%
    ] RUNNINGISR2[];
    CTYPE RUNNINGTASKPRIORITY[];
    TOTRACE ENUM [
%
foreach api in listOfApiFunc do
%      "% !api::NAME %" = % !(INDEX * 2)
between %,
%
end foreach
%
    ] SERVICETRACE[];
    ENUM [
      "E_OK"                       =  0,
      "E_OS_ACCESS"                =  1,
      "E_OS_CALLEVEL"              =  2,
      "E_OS_ID"                    =  3,
      "E_OS_LIMIT"                 =  4,
      "E_OS_NOFUNC"                =  5,
      "E_OS_RESOURCE"              =  6,
      "E_OS_STATE"                 =  7,
      "E_OS_VALUE"                 =  8,
      "E_NOT_OK"                   =  9,
      "E_COM_ID"                   = 10,
      "E_COM_LENGTH"               = 11,
      "E_COM_LIMIT"                = 12,
      "E_COM_NOMSG"                = 13,
      "E_COM_FILTERDOUR"           = 14,
      "E_OS_SERVICEID"             = 16,
      "E_OS_ILLEGAL_ADDRESS"       = 17,
      "E_OS_MISSINGEND"            = 18,
      "E_OS_DISABLEDINT"           = 19,
      "E_OS_STACKFAULT"            = 20,
      "E_OS_PROTECTION_MEMORY"     = 21,
      "E_OS_PROTECTION_TIME"       = 22,
      "E_OS_PROTECTION_ARRIVAL"    = 23,
      "E_OS_PROTECTION_LOCKED"     = 24,
      "E_OS_PROTECTION_EXCEPTION"  = 25,
      "E_OS_INTERFERENCE_DEADLOCK" = 26,
      "E_OS_NESTING_DEADLOCK"      = 27,
      "E_OS_SPINLOCK"              = 28,
      "E_OS_LOST_DATA"             = 29,
      "E_OS_NO_DATA"               = 30
    ] LASTERROR[]; /* FIXME : Not generated */
    ENUM [
      "NOAPPMODE" = "-1",%
foreach appmode in APPMODE do
  if (appmode::DEFAULT) | ([APPMODE length] == 1) then%
      "OSDEFAULTAPPMODE" = "% !INDEX %"%
  else %
      "% !appmode::NAME %" = "% !INDEX %"%
  end if
between %,%
end foreach
  %
    ] CURRENTAPPMODE[];%
if OS::NUMBER_OF_CORES > 1 & [SPINLOCK length] > 0 then%
    CTYPE _vs_HELD_SPINLOCKS[];
    ENUM [
      "NONE" = "-1",%
foreach spinlock in SPINLOCK do%
      "% !spinlock::NAME %" = "% !INDEX %"%
between %,%
end foreach
  %
    ] _vs_LAST_TAKEN_SPINLOCK[];%
end if%
  };

  TASK
  {
    CTYPE PRIORITY;
    ENUM [
      "SUSPENDED" = 0,
      "READY" = 1,
      "RUNNING" = 2,
      "WAITING" = 3,
    ] STATE;
    ENUM [%
foreach proc in PROCESSES do%
      "% !proc::NAME %_stack" = "&(% !proc::NAME %_stack_zone[0])"%
between %,%
end foreach
  %
    ] STACK;
    CTYPE CURRENTACTIVATIONS;
    ENUM [%
foreach proc in PROCESSES do%
      "% !proc::NAME %_context" = "&(tpl_stat_proc_table[% !INDEX %].context)"%
between %,%
end foreach
  %
    ] CONTEXT;
  };

  _vs_ISR
  {
    CTYPE PRIORITY;
    ENUM [
      "SUSPENDED" = 0,
      "READY" = 1,
      "RUNNING" = 2,
      "WAITING" = 3,
    ] STATE;
    ENUM [%
foreach proc in PROCESSES do%
      "% !proc::NAME %_stack" = "&(% !proc::NAME %_stack_zone[0])"%
between %,%
end foreach
  %
    ] STACK;
    CTYPE CURRENTACTIVATIONS;
    ENUM [%
foreach proc in PROCESSES do%
      "% !proc::NAME %_context" = "&(tpl_stat_proc_table[% !INDEX %].context)"%
between %,%
end foreach
  %
    ] CONTEXT;
  };

  STACK
  {
    CTYPE SIZE;
    CTYPE BASEADDRESS;
    STRING STACKDIRECTION;
    CTYPE FILLPATTERN;
  };

  ALARM
  {
    CTYPE ALARMTIME;
    CTYPE CYCLETIME;
    ENUM[
      "STOPPED" = 0,
      "RUNNING" = 1,
      "AUTOSTART" = 2
    ] STATE;
    STRING ACTION;
    STRING COUNTER;
  };

  RESOURCE
  {
    ENUM[
      "UNLOCKED" = 0,
      "LOCKED" = 1,
    ] STATE;
    ENUM [%
foreach proc in PROCESSES do%
      "% !proc::NAME %" = % !INDEX %%
between %,%
end foreach
  %
    ] LOCKER;
    STRING PRIORITY;
  };

  MESSAGECONTAINER
  {
    STRING MSGNAME;
    STRING MSGTYPE;
    CTYPE QUEUESIZE;
    CTYPE QUEUECOUNT;
    CTYPE FIRSTELEMENT;
  };

  _vs_COUNTER
  {
    STRING SOURCE;
    CTYPE MINCYCLE;
    CTYPE TICK;
    CTYPE TICK_PER_BASE;
    CTYPE DATE;
    CTYPE MAX;
    ENUM [
      "HARDWARE" = 0,
      "SOFTWARE" = 1
    ] KIND;
  };

  _vs_SPINLOCK
  {
    STRING LOCKMETHOD;
    ENUM [
      "UNLOCKED" = 0,
      "LOCKED"   = 1
    ] STATE;
  };

  /* ----------------------------------------------------------------------------
   * Architecture dependant orti implementation
   */
%
template if exists custom_orti_implementation
%
};

/* ----------------------------------------------------------------------------
 * Definitions
 */
OS Trampoline_arch
{%
  if OS::NUMBER_OF_CORES > 1 then%
  vs_SMP_NUMCPU = "% !OS::NUMBER_OF_CORES %";
%
  end if
loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
  let orti_core_a := ""
  if OS::NUMBER_OF_CORES > 1 then
    let orti_core_a := "[" + [core_id string] + "]"
  end if
  let orti_tpl_kern := "tpl_kern" + orti_core_a
  let orti_last_error := "tpl_last_error" + orti_core_a
  let orti_current_appmode := "application_mode" + orti_core_a
  let orti_service_trace := "tpl_servicetrace" + orti_core_a
  let orti_held_spinlocks := "tpl_taken_spinlock_counter" + orti_core_a
  let orti_last_taken_spinlock := orti_held_spinlocks + " ? "
                                + "tpl_taken_spinlocks" + orti_core_a
                                + "[" + orti_held_spinlocks + " - 1 ]"
                                + ": -1"

  let orti_running_task_id := orti_tpl_kern + ".running_id"
  let orti_osname := "Trampoline_arch" + orti_core_a
%
  RUNNINGTASK% !orti_core_a % = "% !orti_running_task_id %";
  RUNNINGISR2% !orti_core_a % = "% !orti_running_task_id %";
  RUNNINGTASKPRIORITY% !orti_core_a % = "tpl_dyn_proc_table[% !orti_running_task_id %].priority";
  LASTERROR% !orti_core_a % = "% !orti_last_error %";
  CURRENTAPPMODE% !orti_core_a % = "% !orti_current_appmode %"
  VALID% !orti_core_a % = "% !orti_running_task_id % != -1";
  SERVICETRACE% !orti_core_a % = "% !orti_service_trace %";%
  if OS::NUMBER_OF_CORES > 1 & [SPINLOCK length] > 0 then%
  _vs_HELD_SPINLOCKS% !orti_core_a % = "% !orti_held_spinlocks %";
  _vs_LAST_TAKEN_SPINLOCK% !orti_core_a % = "% !orti_last_taken_spinlock %";%
  end if
between%
%
end loop%
};
%
if OS::NUMBER_OF_CORES > 1 then%
/* Replicated code in multicore to display all Core's informations at the
 * same time.
 */%
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%
_vs_OS CORE_% !core_id %
{%
    let orti_core_a := ""
    if OS::NUMBER_OF_CORES > 1 then
      let orti_core_a := "[" + [core_id string] + "]"
    end if
    let orti_tpl_kern := "tpl_kern" + orti_core_a
    let orti_last_error := "tpl_last_error" + orti_core_a
    let orti_current_appmode := "application_mode" + orti_core_a
    let orti_service_trace := "tpl_servicetrace" + orti_core_a
    let orti_held_spinlocks := "tpl_taken_spinlock_counter" + orti_core_a
    let orti_last_taken_spinlock := orti_held_spinlocks + " ? "
                                  + "tpl_taken_spinlocks" + orti_core_a
                                  + "[" + orti_held_spinlocks + " - 1 ]"
                                  + ": -1"

    let orti_running_task_id := orti_tpl_kern + ".running_id"
    let orti_osname := "Trampoline_arch" + orti_core_a
%
  vs_SMP_NUMCPU = "% !OS::NUMBER_OF_CORES %";
  RUNNINGTASK% !orti_core_a % = "% !orti_running_task_id %";
  RUNNINGISR2% !orti_core_a % = "% !orti_running_task_id %";
  RUNNINGTASKPRIORITY% !orti_core_a % = "tpl_dyn_proc_table[% !orti_running_task_id %].priority";
  LASTERROR% !orti_core_a % = "% !orti_last_error %";
  CURRENTAPPMODE% !orti_core_a % = "% !orti_current_appmode %"
  VALID% !orti_core_a % = "% !orti_running_task_id % != -1";
  SERVICETRACE% !orti_core_a % = "% !orti_service_trace %";%
    if OS::NUMBER_OF_CORES > 1 & [SPINLOCK length] > 0 then%
  _vs_HELD_SPINLOCKS% !orti_core_a % = "% !orti_held_spinlocks %";
  _vs_LAST_TAKEN_SPINLOCK% !orti_core_a % = "% !orti_last_taken_spinlock %";%
    end if%
};
%
  end loop
end if
foreach proc in PROCESSES do
  if proc::KIND == "Task" then
%
TASK % !proc::NAME
  else
%
_vs_ISR % !proc::NAME
  end if
%
{
  PRIORITY = "tpl_dyn_proc_table[% !INDEX %].priority";
  STATE = "tpl_dyn_proc_table[% !INDEX %].state";
  STACK = "&(% !proc::NAME %_stack_zone[0])";
  CURRENTACTIVATIONS = "tpl_dyn_proc_table[% !INDEX %].activate_count";
  CONTEXT = "&(tpl_stat_proc_table[% !INDEX %].context)";
};
%
end foreach

foreach alarm in ALARM do
  let alarm_action := ""
  if alarm::ACTION == "ACTIVATETASK" then
    let alarm_action := "ACTIVATE " + alarm::ACTION_S::TASK
  elsif alarm::ACTION == "SETEVENT" then
    let alarm_action := "SET " + alarm::ACTION_S::TASK
                      + " EVENT " + alarm::ACTION_S::EVENT
  elsif alarm::ACTION == "ALARMCALLBACK" then
    let alarm_action := "CALL " + alarm::ACTION_S::ALARMCALLBACKNAME
  elsif alarm::ACTION == "INCREMENTCOUNTER" then
    let alarm_action := "INCREMENT " + alarm::ACTION_S::COUNTER
  else
    let alarm_action := "UNDEFINED ACTION"
  end if
%
ALARM % !alarm::NAME %
{
    ALARMTIME = "% !alarm::NAME %_alarm_desc.date";
    CYCLETIME = "% !alarm::NAME %_alarm_desc.cycle";
    STATE = "% !alarm::NAME %_alarm_desc.state";
    ACTION = "% ! alarm_action %";
    COUNTER = "% !alarm::COUNTER %";
};
%
end foreach

foreach resource in REGULARRESOURCES do
  let resource_prio
  if [resource::ISRUSAGE length] > 0 then
    let resource_prio := "ISR: " + [resource::PRIORITY string]
  elsif [resource::TASKUSAGE length] > 0 then
    let resource_prio := "TASK: " + [resource::PRIORITY string]
  else
    let resource_prio := "UNUSED: " + [resource::PRIORITY string]
  end if
%
RESOURCE % !resource::NAME %
{
  STATE = "% !resource::NAME %_rez_desc.owner != -1";
  LOCKER = "% !resource::NAME %_rez_desc.owner";
  PRIORITY = "% !resource_prio %";
};
%
end foreach

foreach counter in COUNTERS do
%
_vs_COUNTER % !counter::NAME %
{
  SOURCE = "% !counter::SOURCE %";
  MINCYCLE = "% !counter::NAME %_counter_desc.min_cycle";
  TICK = "% !counter::NAME %_counter_desc.current_tick";
  TICK_PER_BASE = "% !counter::NAME %_counter_desc.ticks_per_base";
  DATE = "% !counter::NAME %_counter_desc.current_date";
  MAX = "% !counter::NAME %_counter_desc.max_allowed_value";%
  if AUTOSAR then%
  KIND = "% !counter::NAME %_counter_desc.kind";%
  end if%
};
%
end foreach

foreach message in MESSAGE do
  let queuesize
  let queuecount
  let messagetype
  let firstelement
  let show := false
  if message::MESSAGEPROPERTY == "RECEIVE_UNQUEUED_INTERNAL" then
    let show := true
    let queuesize := "1"
    let queuecount := "1"
    let messagetype := "UNQUEUED"
    let firstelement := message::NAME + "_buffer"
  elsif message::MESSAGEPROPERTY == "RECEIVE_QUEUED_INTERNAL" then
    let show := true
    let queuesize := [message::MESSAGEPROPERTY_S::QUEUESIZE string]
    let messagetype := "QUEUED"
    let queuecount := message::NAME + "_dyn_queue.size/"
                    + message::NAME + "_message.queue.element_size"
    let queueindex := message::NAME + "_dyn_queue.index/"
                    + message::NAME + "_message.queue.element_size"
    let firstelement := message::NAME + "_buffer[" + queueindex + "]"
  elsif message::MESSAGEPROPERTY == "RECEIVE_ZERO_INTERNAL" then
    let show := true
    let queuesize := "1"
    let queuecount := "1"
    let messagetype := "UNQUEUED"
    let firstelement := ""
  end if

  if show then
%
MESSAGECONTAINER % !message::NAME %
{
  MSGNAME = "% !message::NAME %";
  MSGTYPE = "% !messagetype %";
  QUEUESIZE = "% !queuesize %";
  QUEUECOUNT = "% !queuecount %";
  FIRSTELEMENT = "% !firstelement %";
};
%
  end if
end foreach

foreach spinlock in SPINLOCK do
%
_vs_SPINLOCK % !spinlock::NAME %
{
  LOCKMETHOD = "% !spinlock::LOCKMETHOD %";
  STATE = "% !spinlock::NAME %_spinlock_desc.state";
};
%
end foreach

%
/* ----------------------------------------------------------------------------
 * Architecture dependant orti definitions
 */
%
template if exists custom_orti_definition

%
/* ----------------------------------------------------------------------------
 * End of file % !FILENAME %
 */
%
%
