/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * OS data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

#include <stdbool.h>
#include <stdint.h>

#include "tpl_app_config.h"

#include "tpl_os_internal_types.h"
#include "tpl_machine.h"
#include "tpl_os_interrupt.h"
#include "tpl_os_interrupt_kernel.h"
#include "tpl_os_alarm_kernel.h"
#include "tpl_os_alarm.h"
#include "tpl_os_resource_kernel.h"
#include "tpl_os_resource.h"
#include "tpl_os_event_kernel.h"
#include "tpl_os_event.h"
#include "tpl_os_action.h"
#include "tpl_os_kernel.h"
#include "tpl_os_definitions.h"

%
if USECOM then
%
#include "tpl_com_notification.h"
#include "tpl_com_mo.h"
#include "tpl_com_internal.h"
#include "tpl_com_internal_com.h"
/*#include "tpl_com_external_com.h"*/
#include "tpl_com_app_copy.h"
#include "tpl_com_filters.h"
%
end if

if AUTOSAR then
%
#include "tpl_as_schedtable.h"
#include "tpl_as_st_kernel.h"
#include "tpl_as_action.h"
#include "tpl_as_isr_kernel.h"
#include "tpl_as_isr.h"
#include "tpl_as_counter.h"
#include "tpl_as_app_kernel.h"
#include "tpl_as_trusted_fct.h"
#include "tpl_as_trusted_fct_kernel.h"
#include "tpl_as_application.h"%
  if ([SPINLOCK length] > 0) & (OS::NUMBER_OF_CORES > 1) then%
#include "tpl_as_spinlock.h"
#include "tpl_as_spinlock_kernel.h"
%
  end if
end if

if OS::TIMINGPROTECTION then
%
#include "tpl_as_protec_hook.h"
#include "tpl_as_timing_protec.h"
%
end if

if USEMEMORYPROTECTION then
%
#include "tpl_os_mem_prot.h"
%
end if

# include a user defined types file for messages
if ["tpl_message_cdatatype.h" fileExists] then
  let available_receive_message := false
  foreach mess in MESSAGES do
    if mess::MESSAGEPROPERTY == "RECEIVE_UNQUEUED_INTERNAL" | mess::MESSAGEPROPERTY == "RECEIVE_QUEUED_INTERNAL" then
      let available_receive_message := true
    end if
  end foreach

  if available_receive_message then
%
#include "tpl_message_cdatatype.h"
%
  end if
end if

if [ioc_reordered length] != 0 then
%
#include "tpl_ioc.h"
%
end if

# application mode inclusion
template if exists appmode

%
#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
foreach event in EVENTS
  before
%
/*=============================================================================
 * Declaration of event masks
 */
%
  do
%
/* Event % !event::NAME % */
#define % !event::NAME %_mask % !event::MASK %
CONST(EventMaskType, AUTOMATIC) % !event::NAME % = % !event::NAME %_mask;
%
end foreach

foreach resource in REGULARRESOURCES
  before
%
/*=============================================================================
 * Declaration of resources IDs
 */
%
  do
%
/* Resource % !resource::NAME % */
#define % !resource::NAME %_id % !INDEX %
CONST(ResourceType, AUTOMATIC) % !resource::NAME % = % !resource::NAME %_id;
%
end foreach
%
/*=============================================================================
 * Declaration of processes IDs
 */
%
foreach proc in PROCESSES do
  if proc::KIND == "Task" then
%
/* Task % !proc::NAME % identifier */
#define % !proc::NAME %_id % !INDEX %
CONST(TaskType, AUTOMATIC) % !proc::NAME % = % !proc::NAME %_id;
%
  else
%
/* ISR % !proc::NAME % identifier */
#define % !proc::NAME %_id % !INDEX 
    if AUTOSAR then
    #
    # ISR ids constants are only available for AUTOSAR
    #
%
CONST(ISRType, AUTOMATIC) % !proc::NAME % = % !proc::NAME %_id;
%
    end if
  end if
end foreach

foreach alarm in ALARM
  before
%
/*=============================================================================
 * Declaration of Alarm IDs
 */
%
  do
%
/* Alarm % !alarm::NAME % identifier */
#define % !alarm::NAME %_id % !INDEX %
CONST(AlarmType, AUTOMATIC) % !alarm::NAME % = % !alarm::NAME %_id;
%
end foreach

if AUTOSAR then
  foreach counter in COUNTERS
    before
%
/*=============================================================================
 * Declaration of Counter IDs
 */
%
    do
%
/* Counter % !counter::NAME % identifier */
#define % !counter::NAME %_id % !INDEX %
CONST(CounterType, AUTOMATIC) % !counter::NAME % = % !counter::NAME %_id;
%
  end foreach
end if

if USECOM then
  foreach message in RECEIVEMESSAGES
    before
%
/*=============================================================================
 * Declaration of receive messages IDs
 */
%
    do
%
/* Message % !message::NAME % identifier */
#define % !message::NAME %_id % !INDEX %
CONST(MessageIdentifier, AUTOMATIC) % !message::NAME % = % !message::NAME %_id;
%
  end foreach
  foreach message in SENDMESSAGES
    before
%
/*=============================================================================
 * Declaration of send messages IDs
 */
%
    do
%
/* Message % !message::NAME % identifier */
#define % !message::NAME %_id % !INDEX %
CONST(MessageIdentifier, AUTOMATIC) % !message::NAME % = % !message::NAME %_id;
%
  end foreach
end if

if AUTOSAR then
  foreach st in SCHEDULETABLES
    before
%
/*=============================================================================
 * Declaration of Scheduletables IDs
 */
%
    do
%
/* Schedule table % !st::NAME % identifier */
#define % !st::NAME %_id % !INDEX %
CONST(ScheduleTableType, AUTOMATIC) % !st::NAME % = % !st::NAME %_id;
%
  end foreach

  foreach app in APPLICATIONS
    before
%
/*=============================================================================
 * Declaration of OS Application IDs
 */
%
    do
%
/* OS Application % !app::NAME % identifier */
#define % !app::NAME %_id % !INDEX %
CONST(ApplicationType, OS_APPL_CONST) % !app::NAME % = % !app::NAME %_id;
%
  end foreach

  foreach tf in TRUSTEDFUNCTIONS
    before
%
/*=============================================================================
 * Declaration of Trusted functions IDs
 */
%
    do
%
/* Trusted function % !NAME % identifier */
#define % !NAME %_id % !INDEX %
CONST(TrustedFunctionIndexType, AUTOMATIC) % !NAME % = % !NAME %_id;
%
  end foreach

  if (OS::NUMBER_OF_CORES > 1) then
    foreach spinlock in SPINLOCK
      before
  %
/*=============================================================================
 * Declaration of Spinlock IDs
 */
%
    do
%
/* Spinlock % !spinlock::NAME % identifier */
#define % !spinlock::NAME %_id % !INDEX %
CONST(SpinlockIdType, AUTOMATIC) % !spinlock::NAME % = % !spinlock::NAME %_id;
%
    end foreach
  end if

end if
%
#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
foreach resource in REGULARRESOURCES
  before
%
/*=============================================================================
 * Definition and initialization of regular Resource related structures
 */
%
  do
    template resource_descriptor
end foreach

if OS::USERESSCHEDULER then
%
/**
 * The scheduler resource descriptor.
 * One scheduler resource is defined per core.
 *
 * @see #RES_SCHEDULER
 */
%
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"%
    if OS::NUMBER_OF_CORES > 1 then%
VAR(tpl_resource, OS_VAR) res_sched_core% !core_id %_rez_desc = {%
    else %
VAR(tpl_resource, OS_VAR) res_sched_rez_desc = {%
    end if%
  RES_SCHEDULER_PRIORITY,   /*  ceiling priority                            */
  0,                        /*  owner_prev_priority                         */
  INVALID_PROC_ID,          /*  owner                                       */
#if WITH_OSAPPLICATION == YES
  INVALID_OSAPPLICATION_ID, /*  OS Application id                           */
#endif
%
if OS::USEID then
%
  0,                        /*  resource id                                 */
%
end if
%
  NULL                      /*  next_res                                    */
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
%
  end loop
end if

#------------------------------------------------------------------------------
# resources table.
# generate only if at least one resource exists
#
loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
  if [REGULARRESOURCES length] > 0 | OS::USERESSCHEDULER then
%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2VAR(tpl_resource, AUTOMATIC, OS_APPL_DATA)%
    if OS::NUMBER_OF_CORES > 1 then%
tpl_resource_table_core% !core_id %[RESOURCE_COUNT] = {%
    else%
tpl_resource_table[RESOURCE_COUNT] = {%
    end if
    foreach resource in REGULARRESOURCES
    before %
  %
    do
      # Check if this core has this resource, add the resource descriptor if
      # yes.
      let accessing_application := false
      foreach application in APPLICATIONS do
        if exists application::CORE default(0) == core_id then
          let res_map := mapof exists application::RESOURCE default( @() ) by VALUE
          let app_map := mapof exists resource::ACCESSING_APPLICATION default( @() ) by VALUE
          if (exists res_map[resource::NAME])
           | (exists app_map[application::NAME]) then
            let accessing_application := true
          end if
        end if
      end foreach

      if OS::SCALABILITYCLASS <= 2 then
        let accessing_application := true
      end if

      if accessing_application then
    %&% !resource::NAME %_rez_desc%
      else
    %NULL%
      end if
    between
    %,
  %
    end foreach

    if OS::USERESSCHEDULER then
      if [REGULARRESOURCES length] > 0 then %,% end if
      if OS::NUMBER_OF_CORES > 1 then%
  &res_sched_core% !core_id %_rez_desc%
      else %
  &res_sched_rez_desc%
      end if
    end if
%
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
  end if
end loop

if OS::NUMBER_OF_CORES > 1 then%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2CONST(tpl_resource*, AUTOMATIC, OS_CONST)
tpl_resource_table[NUMBER_OF_CORES] = {
%
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%  tpl_resource_table_core% !core_id
  between %,
%
  end loop
%
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
end if

#------------------------------------------------------------------------------

foreach resource in INTERNALRESOURCES
  before
%
/*=============================================================================
 * Definition and initialization of internal Resource related structures
 */
%
  do
    template internal_resource_descriptor
end foreach

foreach counter in COUNTERS
  before
%
/*=============================================================================
 * Definition and initialization of Counters related defines and structures
 */
%
  do
    template counter_descriptor
end foreach

template counter_call

if AUTOSAR then
  foreach counter in COUNTERS
    before
%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2VAR(tpl_counter, OS_VAR, OS_APPL_DATA)
tpl_counter_table[COUNTER_COUNT] = {
%
    do
      %  &% !counter::NAME %_counter_desc%
    between
      %,
%
    after
%
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
  end foreach
end if

%
/*=============================================================================
 * Descriptor(s) of the idle task(s)
 */
%
template idle_task_descriptors

foreach task in TASKS
  before
%
/*=============================================================================
 * Definition and initialization of Task related defines and structures
 */
%
  do
    template task_descriptor
end foreach

foreach isr in ISRS2
  before
%
/*=============================================================================
 * Definition and initialization of ISR2 related defines and structures
 */
%
  do
    template isr_descriptor
end foreach

template if exists interrupt_table

%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
/*=============================================================================
 * Definition and initialization of process tables (tasks and isrs)
 */
CONSTP2CONST(tpl_proc_static, AUTOMATIC, OS_APPL_DATA)
tpl_stat_proc_table[TASK_COUNT+ISR_COUNT+% ! OS::NUMBER_OF_CORES %] = {
%
foreach proc in PROCESSES do
    %  &% !proc::NAME %_% ![proc::KIND lowercaseString] %_stat_desc,
%
end foreach
if OS::NUMBER_OF_CORES == 1 then
%  &IDLE_TASK_task_stat_desc%
else
  loop core from 0 to OS::NUMBER_OF_CORES - 1 do
    %  &IDLE_TASK_% ! core %_task_stat_desc%
  between %,
%
  end loop
end if
%
};

CONSTP2VAR(tpl_proc, AUTOMATIC, OS_APPL_DATA)
tpl_dyn_proc_table[TASK_COUNT+ISR_COUNT+% ! OS::NUMBER_OF_CORES %] = {
%
foreach proc in PROCESSES do
    %  &% !proc::NAME %_% ![proc::KIND lowercaseString] %_desc,
%
end foreach
if OS::NUMBER_OF_CORES == 1 then
%  &IDLE_TASK_task_desc%
else
  loop core from 0 to OS::NUMBER_OF_CORES - 1 do
    %  &IDLE_TASK_% ! core %_task_desc%
  between %,
%
  end loop
end if
%
};
%
foreach task in EXTENDEDTASKS
  before %
CONSTP2VAR(tpl_task_events, AUTOMATIC, OS_APPL_DATA)
tpl_task_events_table[EXTENDED_TASK_COUNT] = {
%
  do %  &% !task::NAME %_task_evts%
  between %,
%
  after
%
};
%
end foreach
foreach isr in ISRS2
  before
%
CONSTP2CONST(tpl_isr_static, AUTOMATIC, OS_APPL_DATA)
tpl_isr_stat_table[ISR_COUNT] = {
%
  do
    %  &% !isr::NAME %_isr_helper%
  between
    %,
%
  after
    %
};
%
end foreach
template if exists isr_list_specific

%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

%
if AUTOSAR then
  foreach isr in ISRS2
    before
%
VAR(tpl_isr2_enable_state, OS_VAR)
tpl_isr2_enable_table[ISR_COUNT] = {
%
    do
      %  ENABLED%
    between
      %,
%
    after
      %
};
%
  end foreach
end if
foreach alarm in ALARMS
  before
%
/*=============================================================================
 * Definition and initialization of Alarm related structures
 */
%
  do
    template alarm_descriptor
end foreach
foreach alarm in ALARMS
  before
    %
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2VAR(tpl_time_obj, AUTOMATIC, OS_APPL_DATA)
  tpl_alarm_table[ALARM_COUNT] = {
%
  do
    %  &% !alarm::NAME %_alarm_desc%
  between
    %,
%
  after
    %
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
end foreach
%
/*=============================================================================
 * Declaration of flags functions
 */
/* $FLAGSFUNCTIONS$ */

%
foreach filter in FILTERSTRUCTS
  before
%
/*=============================================================================
 * Declaration of the custom filter descriptors
 * filter descriptors are generated according to the type
 * used for the corresponding message object
 */
%
  do
    template filter_desc_struct
end foreach

foreach filter in FILTERS
  before
%
/*=============================================================================
 * Definitions of the custom filter functions
 * filter functions are generated according to the type
 * used for the corresponding message object
 */
%
  do
    template filter_function
end foreach

foreach message in RECEIVEMESSAGES
  before
%
/*=============================================================================
 * Definition and initialization of Receive Messages related structures
 */
%
  do
    template receive_message_descriptor
end foreach

foreach message in RECEIVEMESSAGES
  before
%
/*=============================================================================
 * Definition and initialization of the receive messages table
 */
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONSTP2CONST(tpl_base_receiving_mo, AUTOMATIC, OS_CONST)
tpl_receive_message_table[RECEIVE_MESSAGE_COUNT] = {
%
  do %  (tpl_base_receiving_mo*)&% !message::NAME %_message%
  between %,    
%
  after %
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
end foreach

foreach message in SENDMESSAGES
  before
%
/*=============================================================================
 * Definition and initialization of Send Messages related structures
 */
%
  do
    template send_message_descriptor
end foreach

foreach message in SENDMESSAGES
  before
%
/*=============================================================================
 * Definition and initialization of the send messages table
 */
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONSTP2CONST(tpl_base_sending_mo, AUTOMATIC, OS_CONST)
tpl_send_message_table[SEND_MESSAGE_COUNT] = {
%
  do %  (tpl_base_sending_mo*)&% !message::NAME %_message%
  between %,    
%
  after %
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
end foreach

if AUTOSAR then
  foreach st in SCHEDULETABLES
    before
%
/*=============================================================================
 * Declaration of schedule tables related defines and structures
 */

%
    do
      template scheduletable_descriptor
  end foreach
  foreach st in SCHEDULETABLES
    before %
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONSTP2VAR(tpl_schedule_table, AUTOMATIC, OS_APPL_DATA)
tpl_schedtable_table[% ![SCHEDULETABLES length] %] = {
%
    do %  &% !st::NAME %_st_dyn%
    between %,
%
    after %
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
  end foreach
  foreach app in APPLICATIONS
    before
%
/*=============================================================================
 * Declaration of OS applications related defines and structures
 */
%
    do
    template application_descriptor
  end foreach
  
  foreach app in APPLICATIONS
    before %
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONSTP2CONST(tpl_app_access, OS_APPL_CONST, OS_APPL_CONST) tpl_app_table[APP_COUNT] = {
%
    do %  &% !app::NAME %_app_access%
    between %,
%
    after %
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
  end foreach

  if [APPLICATIONS length] > 0 then %
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
VAR(tpl_app_dyn, OS_VAR) tpl_app_dyn_table[APP_COUNT];
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

%
    if OS::NUMBER_OF_CORES > 1 then
      foreach app in APPLICATIONS
        before %
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONST(tpl_core_id, OS_CONST) tpl_core_id_for_app[APP_COUNT] =
{
%do
%  %!app::CORE
        between %,
%
        after%
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
      end foreach
    end if
  end if

  foreach tf in TRUSTEDFUNCTIONS
    before
%
/*=============================================================================
 * Declaration of Trusted Functions table
 */
#define OS_START_SEC_CODE
#include "tpl_memmap.h"
%
    do %

FUNC(void, OS_APPL_CODE) TRUSTED_% !tf::NAME %(
  CONST(TrustedFunctionIndexType, AUTOMATIC) idx,
  CONST(TrustedFunctionParameterRefType, AUTOMATIC) params);
%
  after
%
#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"
%
  end foreach
  foreach tf in TRUSTEDFUNCTIONS
    before %
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_trusted_fct, OS_APPL_CODE)
  tpl_trusted_fct_table[TRUSTED_FCT_COUNT] = {
%
    do %  TRUSTED_% !tf::NAME
    between %,
%
    after %
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
  end foreach

  if [SPINLOCK length] > 0 then
    template if exists spinlock_structures
  end if

end if

if USEMEMORYPROTECTION then
  foreach proc in PROCESSES do
    template memory_region_descriptor
  end foreach  
%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONSTP2CONST(tpl_mem_prot_desc, AUTOMATIC, OS_CONST) tpl_mp_table[TASK_COUNT+ISR_COUNT+NUMBER_OF_CORES] = {
%
  foreach proc in PROCESSES
    do %  &% !proc::NAME %_mp_desc,
%
  end foreach
  let this_core := 0
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1
    do
      let this_core := core_id
      %  NULL%
    between %, /* Idle% !this_core %*/
%
    after %  /* Idle% !this_core %*/%
  end loop
%
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
% 
end if

let iteration_queued := 0
let iteration_last_is_best := 0
foreach ioc in ioc_reordered 
  before
%/*=============================================================================
 * Declaration of IOC related defines and structures
 */
%
  do
  if ioc::SEMANTICS == "QUEUED" then
%/*-----------------------------------------------------------------------------
 * OsIocCommunication % !ioc::NAME % descriptor
 */
%
    let iteration1 := 0
    foreach typeName in ioc::DATATYPENAME do
%#define OS_START_SEC_VAR_8
#include "tpl_memmap.h"

VAR(tpl_ioc_data, OS_VAR) % !ioc::NAME %_buffer_% !iteration1 %[sizeof(% !typeName::NAME %)*% !ioc::SEMANTICS_S::BUFFER_LENGTH %];

#define OS_STOP_SEC_VAR_8
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_ioc_queue_dyn, OS_VAR) % !ioc::NAME %_queue_dyn_% !iteration1 % =
{
  0,     /* size     */
  0,     /* index    */
  FALSE  /* overflow */
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h" 
%   
    let iteration1 := iteration1 + 1
    end foreach
%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_ioc_queue, OS_CONST) % !ioc::NAME %_queue_stat[% !iteration1 %] =
{
%
    let iteration2 := 0
    foreach typeName in ioc::DATATYPENAME do
% {
    /* dyn_desc     */&% !ioc::NAME %_queue_dyn_% !iteration2 %,
    /* buffer       */% !ioc::NAME %_buffer_% !iteration2 %,
    /* max_size     */% !ioc::SEMANTICS_S::BUFFER_LENGTH %*sizeof(% !typeName::NAME %),
    /* element_size */sizeof(% !typeName::NAME %)
  }%    
    let iteration2 := iteration2 + 1
    between
    %,
    %
    end foreach
%
};

CONST(tpl_ioc_queued_mo, OS_CONST) % !ioc::NAME %_mo =
{
  /* queue */% !ioc::NAME %_queue_stat,
  /* id    */% !iteration_queued %,
  /* nb_mo */% !iteration2 %
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%    
  let iteration_queued := iteration_queued + 1
  elsif ioc::SEMANTICS == "LAST_IS_BEST" then
%/*-----------------------------------------------------------------------------
 * OsIocCommunication % !ioc::NAME % descriptor
 */
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

%
    let iteration1 := 0
    foreach typeName in ioc::DATATYPENAME do
      if typeof ioc::SEMANTICS_S::INIT_VALUE_SYMBOL == @enum then if ioc::SEMANTICS_S::INIT_VALUE_SYMBOL == $auto then 
      % %#%CONST(% !typeName::VALUE %, OS_CONST) % !ioc::NAME %_init_buffer_% !iteration1 % = 0;%
      end if
      else
      %CONST(% !typeName::NAME %, OS_CONST) % !ioc::NAME %_init_buffer_% !iteration1 % = % !ioc::SEMANTICS_S::INIT_VALUE_SYMBOL %;%
      end if
    let iteration1 := iteration1 + 1
    between
    %
    %
    end foreach
%

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h" 

#define OS_START_SEC_VAR_8
#include "tpl_memmap.h"

%
    let iteration2 := 0
    foreach typeName in ioc::DATATYPENAME do
    %VAR(tpl_ioc_data, OS_VAR) % !ioc::NAME %_buffer_% !iteration2 %[sizeof(% !typeName::NAME %)];%
    let iteration2 := iteration2 + 1
    end foreach
%

#define OS_STOP_SEC_VAR_8
#include "tpl_memmap.h"

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_ioc_buffer, OS_CONST) % !ioc::NAME %_init_buffer[% !iteration2 %] =
{
%
    let iteration3 := 0
    foreach typeName in ioc::DATATYPENAME do
      if typeof ioc::SEMANTICS_S::INIT_VALUE_SYMBOL == @enum then if ioc::SEMANTICS_S::INIT_VALUE_SYMBOL == $auto then
      % NULL_PTR%
      end if
      else
      % (tpl_ioc_buffer)&% !ioc::NAME %_init_buffer_% !iteration3
      end if
    let iteration3 := iteration3 + 1
    between
    %,
    %
    end foreach
%
};

CONST(tpl_ioc_buffer, OS_CONST) % !ioc::NAME %_buffer[% !iteration2 %] = 
{
%
    let iteration4 := 0
    foreach typeName in ioc::DATATYPENAME do
    %  %!ioc::NAME%_buffer_% !iteration4
    let iteration4 := iteration4 + 1
    between
    %,
    %
    end foreach
% 
};

CONST(tpl_ioc_message_size, OS_CONST) % !ioc::NAME %_message_size[% !iteration2 %] =
{
%
    let iteration5 := 0
    foreach typeName in ioc::DATATYPENAME do
    %  sizeof(% !typeName::NAME %)%
    let iteration5 := iteration5 + 1
    between
    %,
    %
    end foreach
% 
};

CONST(tpl_ioc_unqueued_mo, OS_CONST) % !ioc::NAME %_mo =
{
  /* buffer       */% !ioc::NAME %_buffer,
  /* init_buffer  */% !ioc::NAME %_init_buffer,
  /* element_size */% !ioc::NAME %_message_size,
  /* id           */% !(iteration_last_is_best + iteration_queued)%,
  /* nb_mo        */% !iteration5 %
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
  let iteration_last_is_best := iteration_last_is_best + 1  
  end if
end foreach

  if [ioc_queued_list length] != 0 then
%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONSTP2CONST(tpl_ioc_queued_mo, OS_CONST, OS_CONST) tpl_ioc_queued_table[% !ioc_queued_count %] =
{
%
   foreach ioc in ioc_queued_list do
     %  &% !ioc::NAME %_mo%
   between
     %,
     %
   end foreach
%
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
  end if
  if [ioc_unqueued_list length] != 0 then
%#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONSTP2CONST(tpl_ioc_unqueued_mo, OS_CONST, OS_CONST) tpl_ioc_unqueued_table[% !ioc_unqueued_count %] =
{
%
   foreach ioc in ioc_unqueued_list do
     % &% !ioc::NAME %_mo%
   between
     %,
     %
   end foreach
%
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

%
  end if

template if exists custom_app_config_c

template heap_readylist

template tpl_kern

template tpl_core_status

foreach proc in PROCESSES
  before
%
#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2CONST(char, AUTOMATIC, OS_APPL_DATA) proc_name_table[TASK_COUNT + ISR_COUNT + 1] = {
%
  do
    %
  "% !proc::NAME %",%
  after
%
  "*idle*"
};
#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
end foreach
%

/* End of file tpl_app_config.c */
