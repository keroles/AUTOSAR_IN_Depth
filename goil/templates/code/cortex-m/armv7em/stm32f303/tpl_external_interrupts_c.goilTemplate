/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * External interrupts init and acknowledge functions for % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the GNU Public Licence v2
 *
 */

#include "tpl_machine.h"
#include "tpl_cortex_definitions.h"
#include "pinAccess.h"

%
#
# Initialize registers according to the pin selected to trigger an external
# interrupt.
#
# Related documentation may be found in the RM0090 Reference manual
#
%
/*
 * External Interrupts initialization for the STM32F303 Microcontroller
 *
 * Interrupt vectors are EXTI0_IRQ, EXTI1_IRQ, EXTI2_IRQ, EXTI3_IRQ, EXTI4_IRQ
 * EXTI5_9_IRQ and EXTI15_10_IRQ
 *
 * Inits are done according to the source(s) pin(s) selected for an interrupt
 * vector corresponding to an or a set of interrupt(s) line(s)
 */
#define OS_START_SEC_CODE
#include "tpl_memmap.h"

FUNC(void, OS_CODE) tpl_init_external_interrupts()
{%

# look for EXTIx_IRQ interrupt sources in COUNTERS and ISR
let ITOBJ := COUNTER | ISR

let filteredItObj := @()

# Check subattributes are defined for EXTIxxx it sources
# This should be done by goil according to the IMPLEMENTATION but currently
# a bug prevents this checking
foreach obj in ITOBJ do
  if exists obj::SOURCE then
    if [obj::SOURCE leftSubString: 4] == "EXTI" then
      if not exists obj::SOURCE_S then
        error obj::SOURCE : "External Interrupts need PIN (EXTI0_IRQ to EXTI4_IRQ) or PINONx (EXTI9_5_IRQ or EXTI15_10_IRQ) with x being the interrupt line number"
      else
        let filteredItObj += obj
      end if
    end if
  end if
end foreach

let USED_EXTI := @[ ]

# Check for sanity of the description and gather multiple pins for EXTI9_5_IRQ
# and EXTI15_10_IRQ
foreach obj in filteredItObj do
  if not exists USED_EXTI[obj::SOURCE] then
    if exists obj::SOURCE_S then
      let USED_EXTI[obj::SOURCE] := mapof obj::SOURCE_S end
    end if
  else
    let knownpins := USED_EXTI[obj::SOURCE]
    # another object is connected to the same line. Check pins are compatible
    if exists knownpins["PIN"] then
      # EXTI0 to EXTI4 may only have one PIN
      if knownpins["PIN"] != obj::SOURCE_S::PIN then
        error obj::SOURCE_S::PIN : obj::SOURCE." may only have one PIN connected"
        error knownpins["PIN"] : "previous declaration was here"
      end if
    else
      # EXTI9_5_IRQ and EXTI15_10_IRQ may have 5 or 6 pins
      let newPinMap := mapof obj::SOURCE_S end
      # Check the same PINON is not used with different pins across IT objects
      foreach pinon in newPinMap do
        if exists knownpins[KEY] then 
          if pinon != knownpins[KEY] & not exists recordedError[knownpins[KEY]] then 
            error newPinMap[KEY] : obj::SOURCE." should connect to the same pin"
            error knownpins[KEY] : "previous declaration was here"
            let recordedError[knownpins[KEY]] := ""
          end if
        else
          # gather pins
          let knownpins[KEY] := pinon
        end if
      end foreach
    end if
    # update pins for IRQ source
    let USED_EXTI[obj::SOURCE] := knownpins
  end if
end foreach

let usedGPIO := @[ ]
let usedPortPin := @[ ]

foreach src in USED_EXTI do
  foreach pin in src do
    if typeof pin == @string then
      let portPin::TRIGGER := exists src[KEY+"_S"]::TRIGGER default ("RISING")
      let portPin::PULL := exists src[KEY+"_S"]::PULL default ("NONE")
      let portPin::NUMBER := [pin subString: 2, 2]
      let portPin::GPIO := [pin subString: 1, 1]
      let usedPortPin[pin] := portPin
      let gpio := [pin subString: 1, 1]
      if not exists usedGPIO[gpio] then
        let usedGPIO[gpio] := @( )
      end if
      let usedGPIO[gpio] += portPin
    end if
  end foreach
end foreach

%
// ---
%
foreach pin in usedPortPin
before%
    /* Program the pins of the GPIO */
%
do
%    pinMode(GPIO%!pin::GPIO%,%!pin::NUMBER%,%
    if    pin::PULL == "NONE" then %INPUT%
    elsif pin::PULL == "UP"   then %INPUT_PULLUP%
    elsif pin::PULL == "DOWN" then %INPUT_PULLDOWN%
    else error here: "error: invalid pin pull up/down mode!"
    end if
    %);
%
end foreach
%
    /* Set the clock for SYSCFG */
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
    RCC->APB2ENR; /* force read access */

    /* Set Interrupt Mask Register */
%
let pinSet := @! ! #set of pin numbers
foreach pin in usedPortPin
  do let pinSet += pin::NUMBER
end foreach
foreach pin in pinSet
  before %    EXTI->IMR |= %
  do %EXTI_IMR_MR%!pin
  between %\n               |  %
  after %;%
end foreach
%

    /* select port associated to each interrupt */
%
foreach pin in usedPortPin do
  let regId := [pin::NUMBER unsigned] >> 2
  %    SYSCFG->EXTICR[%!regId%] &= ~SYSCFG_EXTICR%!regId+1%_EXTI%!pin::NUMBER%; /*P%!pin::GPIO !pin::NUMBER%*/\n%
  %    SYSCFG->EXTICR[%!regId%] |=  SYSCFG_EXTICR%!regId+1%_EXTI%!pin::NUMBER%_P%!pin::GPIO%; /* isr on P%!pin::GPIO !pin::NUMBER% */\n%
  between %\n%
end foreach
%
    /* select trigger mode - RISING, FALLIN, BOTH */
%
foreach pin in usedPortPin do
  if pin::TRIGGER == "RISING" | pin::TRIGGER == "BOTH" then
    %    EXTI->RTSR |=  EXTI_RTSR_TR%!pin::NUMBER%;%
  else
    %    EXTI->RTSR &= ~EXTI_RTSR_TR%!pin::NUMBER%;%
  end if
  % /* P%!pin::GPIO !pin::NUMBER% : %!pin::TRIGGER% */\n%
  if pin::TRIGGER == "FALLING" | pin::TRIGGER == "BOTH" then
    %    EXTI->FTSR |=  EXTI_FTSR_TR%!pin::NUMBER%;\n%
  else
    %    EXTI->FTSR &= ~EXTI_FTSR_TR%!pin::NUMBER%;\n%
  end if
  between %\n%
end foreach
%
// -------------------------------------------------------------------------------------
%

# Program the NVIC. The priority depends on the kind of object. For counters,
# and ISR2, priority is set to OS_ISR_PRIO_UNSHIFTED and for ISR1, it is set
# according to the ISR1 priority.

sort ISRS1 by PRIORITY <

let isr1_prio := (1 << CORTEX::PRIO_BITS) - 2
let last_isr1_prio := -1

let prioForChannel := @[]
foreach name, channel in USED_EXTI do
  foreach obj in filteredItObj do
    if obj::SOURCE == name then
    
      let prio

      if exists obj::CATEGORY then
        if obj::CATEGORY == 2 then
          let prio := "OS_ISR_PRIO_UNSHIFTED"
        else
          let prio := obj::SOURCE + "_Priority"
        end if
      else
        let prio := "OS_ISR_PRIO_UNSHIFTED"
      end if

      if exists prioForChannel[name] then
        if prioForChannel[name] != prio then
          error obj::SOURCE : "Uncompatible priority for sources"
        end if
      else
        let prioForChannel[name] := prio
      end if
    end if 
  end foreach
end foreach

foreach src in USED_EXTI
before%
  /* Program the NVIC */
%
do%
    NVIC_SetPriority(%!KEY%n,%!prioForChannel[KEY]%);
    NVIC_EnableIRQ(%!KEY%n);
%
end foreach
%
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"

/* End of file % !FILENAME % */

