/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * External interrupts init and acknowledge functions for % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

#include "tpl_machine.h"

%
#
# Initialize registers according to the pin selected to trigger an external
# interrupt.
#
# Related documentation may be found in the RM0090 Reference manual
#
%
/*
 * External Interrupts initialization for the % !BOARD % Microcontroller
 *
 * Interrupt vectors are PORTA_IRQ, PORTB_IRQ, PORTC_IRQ, PORTD_IRQ and
 * PORTE_IRQ,
 *
 * Inits are done according to the source(s) pin(s) selected for an interrupt
 * vector corresponding to an or a set of interrupt(s) line(s)
 */
#define OS_START_SEC_CODE
#include "tpl_memmap.h"

FUNC(void, OS_CODE) tpl_init_external_interrupts()
{%

# look for EXTIx_IRQ interrupt sources in COUNTERS and ISR
#let ITOBJ := COUNTER . ISR
#
## Check subattributes are defined for EXTIxxx it sources
## This should be done by goil according to the IMPLEMENTATION but currently
## a bug prevents this checking
#foreach obj in ITOBJ do
#  if exists obj::SOURCE then
#    if [obj::SOURCE leftSubString: 4] == "EXTI" then
#      if not exists obj::SOURCE_S then
#        error obj::SOURCE : "External Interrupts need PIN (EXTI0_IRQ to EXTI4_IRQ) or PINONx (EXTI9_5_IRQ or EXTI15_10_IRQ) with x being the interrupt line number"
#      end if
#    end if
#  end if
#end foreach
#
#let USED_EXTI := emptymap
#
## Check for sanity of the description and gather multiple pins for EXTI9_5_IRQ
## and EXTI15_10_IRQ
#foreach obj in ITOBJ do
#  if not exists USED_EXTI[obj::SOURCE] then
#    if exists obj::SOURCE_S then
#      let USED_EXTI[obj::SOURCE] := mapof obj::SOURCE_S end
#    end if
#  else
#    let knownpins := USED_EXTI[obj::SOURCE]
#    # another object is connected to the same line. Check pins are compatible
#    if exists knownpins["PIN"] then
#      # EXTI0 to EXTI4 may only have one PIN
#      if knownpins["PIN"] != obj::SOURCE_S::PIN then
#        error obj::SOURCE_S::PIN : obj::SOURCE." may only have one PIN connected"
#        error knownpins["PIN"] : "previous declaration was here"
#      end if
#    else
#      # EXTI9_5_IRQ and EXTI15_10_IRQ may have 5 or 6 pins
#      let newPinMap := mapof obj::SOURCE_S end
#      # Check the same PINON is not used with different pins across IT objects
#      foreach pinon in newPinMap do
#        if exists knownpins[KEY] then 
#          if pinon != knownpins[KEY] & not exists recordedError[knownpins[KEY]] then 
#            error newPinMap[KEY] : obj::SOURCE." should connect to the same pin"
#            error knownpins[KEY] : "previous declaration was here"
#            let recordedError[knownpins[KEY]] := ""
#          end if
#        else
#          # gather pins
#          let knownpins[KEY] := pinon
#        end if
#      end foreach
#    end if
#    # update pins for IRQ source
#    let USED_EXTI[obj::SOURCE] := knownpins
#  end if
#end foreach
#
#let usedGPIO := emptymap
#let usedPortPin := emptymap
#foreach src in USED_EXTI do
#  foreach pin in src do
#    if typeof pin == @string then
#      let portPin::TRIGGER := exists src[KEY."_S"]::TRIGGER default ("RISING")
#      let portPin::PULL := exists src[KEY."_S"]::PULL default ("NONE")
#      let portPin::NUMBER := [pin rightSubString: 1]
#      let portPin::GPIO := [pin subString: 1, 1]
#      let usedPortPin[pin] := portPin
#      let gpio := [pin subString: 1, 1]
#      if not exists usedGPIO[gpio] then
#        let usedGPIO[gpio] := emptylist
#      end if
#      let usedGPIO[gpio] += portPin
#    end if
#  end foreach
#end foreach
#
#if [usedPortPin length] > 0 then%
#  GPIO_InitTypeDef GPIO_InitDef;
#  EXTI_InitTypeDef EXTI_InitDef;
#  NVIC_InitTypeDef NVIC_InitDef;
#%
#end if
#
## activate clock for each port GPIO used
#foreach gpio in usedGPIO
#before
#%
#  /*
#   * Program the clocks for the input used in the interrupt sources
#   */%
#do
#%
#  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIO% !KEY %, ENABLE);%
#end foreach
#
## Program each input pin
#
#foreach pin in usedPortPin
#before%
#
#  /*
#   * Program the pins of the GPIO
#   */%
#do
#%
#  GPIO_InitDef.GPIO_Pin = GPIO_Pin_% !pin::NUMBER %;
#  GPIO_InitDef.GPIO_Mode = GPIO_Mode_IN;
#  GPIO_InitDef.GPIO_PuPd = GPIO_PuPd_%
#  if pin::PULL == "NONE" then !"NOPULL"
#  else !pin::PULL
#  end if%;
#  GPIO_InitDef.GPIO_Speed = GPIO_Speed_100MHz;
#  GPIO_Init(GPIO% !pin::GPIO %, &GPIO_InitDef);%
#between%
#%
#end foreach
#
## Program the external interrupt lines
#foreach pin in usedPortPin
#before%
#
#  /*
#   * Set the EXTI line to the corresponding pin
#   */
#   
#  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
#%
#do%
#  SYSCFG_EXTILineConfig(EXTI_PortSourceGPIO% !pin::GPIO %, EXTI_PinSource% !pin::NUMBER %);%
#end foreach
#
## Program each external interrupt line
#foreach pin in usedPortPin
#before%
#
#  /*
#   * Program each EXTI line
#   */%
#do%  
#  EXTI_InitDef.EXTI_Line = EXTI_Line% !pin::NUMBER %;% tab 60 %/* % !KEY % connected to line % !pin::NUMBER tab 88%*/
#  EXTI_InitDef.EXTI_LineCmd = ENABLE;% tab 60 %/* Interrupt enabled% tab 88 %*/
#  EXTI_InitDef.EXTI_Mode = EXTI_Mode_Interrupt;% tab 60 %/* Interrupt mode% tab 88 %*/
#  EXTI_InitDef.EXTI_Trigger = EXTI_Trigger_%
#  if    pin::TRIGGER == "RISING" then %Rising%
#  elsif pin::TRIGGER == "FALLING" then %Falling%
#  else  %Rising_Falling%
#  end if %;% tab 60 %/* Trigger on % ![[pin::TRIGGER lowercaseString] stringByCapitalizingFirstCharacter]% edge% tab 88 %*/
#  EXTI_Init(&EXTI_InitDef);% tab 60 %/* Add to EXTI% tab 88 %*/%
#between%
#%
#end foreach
#
## Program the NVIC. On this target, the priority of kernel (SVC) and Systick
## are set to 0 (the highest available). So All priorities are set 0
#
#foreach src in USED_EXTI
#before%
#
#  /*
#   * Program the NVIC
#   */
#%
#do%
#  NVIC_InitDef.NVIC_IRQChannel = % !KEY %n;
#  NVIC_InitDef.NVIC_IRQChannelPreemptionPriority = 0x00;% tab 60 %/* Set priority% tab 88 %*/
#  NVIC_InitDef.NVIC_IRQChannelSubPriority = 0x00;% tab 60 %/* Set sub priority% tab 88 %*/
#  NVIC_InitDef.NVIC_IRQChannelCmd = ENABLE;% tab 60 %/* Enable interrupt% tab 88 %*/
#  NVIC_Init(&NVIC_InitDef);% tab 60 %/* Add to NVIC% tab 88 %*/%
#end foreach
%
}
%
## Generate all the ClearFlag functions.
#foreach src in USED_EXTI
#before%
#/*
# * External Interrupt acknowledge functions
# */
#%
#do
#%
#/*
# * Interrupt acknowledge of % !KEY %
# */
#FUNC(void, OS_CODE) % !KEY %_ClearFlag(void)
#{
#  EXTI_ClearFlag(%
#
#  if exists src["PIN"] then
#    %EXTI_Line% !usedPortPin[src["PIN"]]::NUMBER
#  else
#    let lineList := emptylist
#    foreach pin in src do
#      if typeof pin == @string then
#        let lineList += "EXTI_Line".usedPortPin[pin]::NUMBER
#      end if 
#    end foreach
#    foreach line in lineList
#    do
#      !line::VALUE
#    between
#      % | %
#    end foreach
#  end if
#  
#%);  
#}%
#end foreach
%
#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"

/* End of file % !FILENAME % */

