/**
 * @file % !FILENAME %
 *
 * @section File description
 *
 * This file gathers all data types which are generated from the application.
 * Please refer to comment of each type for more details.
 * Generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

#ifndef TPL_APP_CUSTOM_TYPES_H
#define TPL_APP_CUSTOM_TYPES_H

#include "tpl_compiler.h"
#include "tpl_os_std_types.h"

/**
 * tpl_heap_key is the datatype used to store the key of a heap entry.
 */
typedef uint% ! KEY_SIZE * 8 % tpl_heap_key;

/**
 * tpl_rank_count is the datatype used to store the rank of an activation
 * It is the lower part of a tpl_heap_key
 */
typedef uint% ! [RANK_MASK numberOfBytes] * 8% tpl_rank_count;

/**
 * tpl_proc_id is used for task and isrs identifiers.
 *
 * @warning This data type must be signed
 * because -1 is used for INVALID_TASK and INVALID_ISR
 */
typedef sint% ! [[PROCESSES length] + 1 signedNumberOfBytes] * 8 % tpl_proc_id;

/**
 * tpl_appmode_mask is used for AUTOSTART objects.
 *
 * Each bit in the mask corresponds to an application mode. The size of the mask
 * is computed according to the number of application modes.
 */
typedef uint% ! [1 << [APPMODE length] - 1 numberOfBytes] * 8 % tpl_appmode_mask;

/**
 * tpl_priority represents a task's or a resource's priority.
 *
 * The data type is computed according to the number of ISR2 and jobs that can * be present in the list of ready tasks.
 */
typedef uint% !8*KEY_SIZE % tpl_priority;

/**
 * tpl_activate_counter is used to count
 * how many time a task has been activated while
 * it was not suspended.
 */%
let max_activation := 0
foreach task in BASICTASKS do
  if task::ACTIVATION > max_activation then
    let max_activation := task::ACTIVATION
  end if
end foreach
%
typedef uint% ![max_activation numberOfBytes] * 8% tpl_activate_counter;

/**
 * tpl_event_mask is used for event.
 * An event is a bit vector. According to the maximum number of events
 * defined in the application, it can be uint8 (8 events), uint16 (16 events) or
 * uint32 (32 events).
 */%

%
typedef uint% ![ALLEVENTSMASK numberOfBytes] * 8 % tpl_event_mask;

/**
 * tpl_alarm_type is used for alarm identifiers.
 */
typedef uint% ![[ALARMS length] numberOfBytes] * 8 % tpl_alarm_id;

/**
 * tpl_resource_id is used for resource identifiers.
 *
 * @warning RES_SCHEDULER is set to the higher resource id + 1
 */
typedef uint% ![[REGULARRESOURCES length]  numberOfBytes] * 8 % tpl_resource_id;

#if (WITH_TRACE == YES)
/**
 * @internal
 *
 * Type used to store the id of an alarm or a schedule table
 * This is used only for tracing
 */
typedef uint% ![[ALARMS length] + [SCHEDULETABLES length] numberOfBytes] * 8 % tpl_timeobj_id;

/**
 * @internal
 *
 * one id for each counter.
 */
typedef uint% ![[COUNTER length] numberOfBytes] * 8 % tpl_trace_counter_id;
#endif

#ifdef WITH_AUTOSAR
/**
 * @internal
 *
 * @todo: document this
 */
typedef uint% ![[SOFTWARECOUNTERS length] numberOfBytes] * 8 % tpl_counter_id;

/**
 * @internal
 *
 * @todo: document this
 */
typedef uint% ![[SCHEDULETABLES length] numberOfBytes] * 8 % tpl_schedtable_id;

/**
 * @internal
 *
 * Type used to store the id of an OS Application
 * Its size is computed according to the number of OS Applications
 */
typedef uint% ![[APPLICATION length] numberOfBytes] * 8 % tpl_app_id;
%
if OS::NUMBER_OF_CORES > 1 then%
/**
 * @internal
 *
 * Type used to store the id of a Spinlock
 * Its size is computed according to the number of Spinlocks
 */
typedef uint% ![[SPINLOCK length] numberOfBytes] * 8 % tpl_spinlock_id;

/**
 * @internal
 *
 * Type used to define if a lock has been successfuly taken or not.
 * Possible values : TRYTOGETSPINLOCK_SUCCESS
 *                   TRYTOGETSPINLOCK_NOSUCCESS
 */
typedef uint8 tpl_try_to_get_spinlock_type;

#define TRYTOGETSPINLOCK_SUCCESS    1
#define TRYTOGETSPINLOCK_NOSUCCESS  0

/**
 * @internal
 *
 * Type used to store the bitfield of possible successor spinlocks indexed by
 * their ids.
 * Its size is given by the SPINLOCK_BITFIELD_CELL_SIZE global variable
 */%
%
typedef uint% !SPINLOCK_BITFIELD_CELL_SIZE % tpl_spinlock_successor_bitfield;

%end if%
/**
 * @internal
 *
 * Generic type used in OS Application API
 * Its size is computed by doing the max of all object kind
 */%
let max_id := 0
if [PROCESSES length] + 1 > max_id then let max_id := [PROCESSES length] + 1 end if
if [ALARMS length] > max_id then let max_id := [ALARMS length] end if
if [RESOURCES length] > max_id then let max_id := [RESOURCES length] end if
if [SOFTWARECOUNTERS length] > max_id then let max_id := [SOFTWARECOUNTERS length] end if
if [SCHEDULETABLES length] > max_id then let max_id := [SCHEDULETABLES length] end if
%
typedef uint% ![max_id numberOfBytes] * 8 % tpl_generic_id;

%
if [ioc_reordered length] != 0 then
%/**
 * @internal
 *
 * Type used to store the id of an IocCommunication
 * Its size is computed by doing the max of all object kind
 */
%
 if [ioc_reordered length] < 256 then
   %typedef uint8 tpl_ioc_id;%
 elsif [ioc_reordered length] < 65536 then
   %typedef uint16 tpl_ioc_id;%
 else
   %typedef uint32 tpl_ioc_id;%
 end if
 
%

/**
 * @internal
 *
 * Type used to store the number of elements of one IocCommunication
 * Its size is computed by doing the max of all object kind
 */
%
 let max_DataTypeSize := 0
 foreach ioc in ioc_reordered do
  let temp := [ioc::DATATYPENAME length]
  if temp > max_DataTypeSize then
    let max_DataTypeSize := temp
  end if
 end foreach

 if max_DataTypeSize < 256 then
   %typedef uint8 tpl_ioc_size;%
 elsif max_DataTypeSize < 65536 then
   %typedef uint16 tpl_ioc_size;%
 else
   %typedef uint32 tpl_ioc_size;%
 end if

%

/**
 * @internal
 *
 * Type used to store the queue size of an IocCommunication
 * Its size is computed by doing the max of all object kind
 */
%

 let max_QueueSize := 0
 foreach ioc in ioc_queued_list do
  let temp := ioc::SEMANTICS_S::BUFFER_LENGTH
  if temp > max_QueueSize then
    let max_QueueSize := temp
  end if
 end foreach

 if max_QueueSize < 256 then
   %typedef uint8 tpl_ioc_queue_size;%
 elsif max_QueueSize < 65536 then
   %typedef uint16 tpl_ioc_queue_size;%
 else
   %typedef uint32 tpl_ioc_queue_size;%
 end if

end if
%

#endif /* WITH_AUTOSAR */

/* target specific types */

% template if exists tpl_target_specific_types or % 
/**
 * tpl_tick is used for relative and absolute dates.
 * tpl_tick should be an unsigned datatype.
 *
 * Default aliased type is "unsigned long int"
 */
typedef uint32 tpl_tick;
%end template%

#endif /* TPL_APP_CUSTOM_TYPES_H */

/* End of file % !FILENAME % */

