/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * lcf file for MPC551x single core or e200z1 (processor 0) combined with
 * e200z0 (processor 1) code.
 *
 * Note internal memory configurations vary from 512KB to 1MB flash and
 * from 32KB to 64KB RAM depending on MPC551x variant.
 *
 * These memory region definitions will allow the stationery example to run
 * on the smallest internal memory device (512KB Flash, 32KB SRAM).
 *
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

MEMORY
{
  resetvector:           org = 0x00000000,   len = 0x00000008
  critical_input :       org = 0x00001000,   len = 0x10
  machine_check :        org = 0x00001010,   len = 0x10
  data_storage :         org = 0x00001020,   len = 0x10
  instruction_storage :  org = 0x00001030,   len = 0x10
  external_interrupt :   org = 0x00001040,   len = 0x10
  alignment :            org = 0x00001050,   len = 0x10
  program :              org = 0x00001060,   len = 0x10
  fp_unavailable :       org = 0x00001070,   len = 0x10
  system_call:           org = 0x00001080,   len = 0x10
  exception_handlers_p0: org = 0x00001000,   len = 0x00001000
  exception_handlers_p1: org = 0x00002000,   len = 0x00001000    
  internal_flash:        org = 0x00003000,   len = 0x0007D000

  internal_ram:          org = 0x40000000,   len = 0x00005000
  heap  :                org = 0x40005000,   len = 0x00000800 /* z1 Heap  */
  stack :                org = 0x40005800,   len = 0x00001000 /* z1 Stack */
  heap_p1  :             org = 0x40006800,   len = 0x00000800 /* z0 Heap  */
  stack_p1 :             org = 0x40007000,   len = 0x00001000 /* z0 Stack */    
}

/* This will ensure the rchw and reset vector are not stripped by the linker */
FORCEACTIVE { "bam_rchw" "bam_resetvector" }

SECTIONS
{
  .__bam_bootarea LOAD (0x00000000): {} > resetvector

  /* Note the intc_hw_branch_table, if used, MUST be loaded at the */
  /* IVPR + 2KB (0x800)  That means if the code loaded into the    */
  /* .__exception_handlers_p* section is larger than 0x700 bytes,  */
  /* the following group(s) must be reconfigured.                  */
    
  .system_call         LOAD (0x00001080) : { *(.SC_vector) }                  > system_call
  .critical_input      LOAD (0x00001000) : { *(.exCriticalInput) }            > critical_input
  .machine_check       LOAD (0x00001010) : { *(.exMachineCheck) }             > machine_check
  .data_storage        LOAD (0x00001020) : { *(.exDataStorage) }              > data_storage
  .instruction_storage LOAD (0x00001030) : { *(.exInstructionStorage) }       > instruction_storage
  .external_interrupt  LOAD (0x00001040) : { *(.EI_vector) }                  > external_interrupt
  .alignment           LOAD (0x00001050) : { *(.exAlignment) }                > alignment
  .program             LOAD (0x00001060) : { *(.exProgram) }                  > program
  .fp_unavailable      LOAD (0x00001070) : { *(.exFloatingPointUnavailable) } > fp_unavailable

  GROUP : {
//      .ivor_branch_table_p0  LOAD (0x00001000)   : {}
    .intc_hw_branch_table_p0 LOAD (0x00001800): {}           
    .__exception_handlers_p0   LOAD (0x00001100) : {}
  } > exception_handlers_p0

  GROUP : {
    .ivor_branch_table_p1  LOAD (0x00002000)   : {}
    .intc_hw_branch_table_p1 LOAD (0x00002800): {}   
    .__exception_handlers_p1  LOAD (0x00002100) : {}
  } > exception_handlers_p1

  GROUP  : {
    .intc_sw_isr_vector_table_p0 ALIGN (2048) : {}
    .intc_sw_isr_vector_table_p1 ALIGN (2048) : {}

    .init : {}
    .init_vle (VLECODE) : {
      *(.init)
      *(.init_vle)
    }
    .osCode ALIGN(32) : {
      __PROGCONST_SECTION_START = .;
   *(.EI_handler)
   *(.SC_handler)
   *(.osCode)
   *(.appCommonCode)
 }
    .text : { *(.text) *(.osApiCode) } 
    .text_vle (VLECODE) ALIGN(0x1000): {
      *(.text)
      *(.text_vle)
    }

/* Sections for code of tasks and ISR */%
foreach proc in PROCESSES do
%
    .% !proc::KIND %_% !proc::NAME %Code : { *(.% !proc::KIND %_% !proc::NAME %Code) }
%
end foreach
%
    .rodata (CONST) : {
      *(.rdata)
      *(.rodata)
      *(.osConst)
      *(.osApiConst)
/* Sections for const of tasks and ISR */
%
for DATA_SIZE in "32BIT","16BIT","8BIT","BOOLEAN","UNSPECIFIED" do
  for SECTION_KIND in "_CONST_","_CALIB_","_CARTO_","_CONFIG_DATA_" do
    foreach proc in PROCESSES do
%      *(.% !proc::KIND %_% !proc::NAME %_SEC% !SECTION_KIND !DATA_SIZE %)
%
    end foreach
  end for
end for
%    
/* Sections for application const */  
%
for DATA_SIZE in "32BIT","16BIT","8BIT","BOOLEAN","UNSPECIFIED" do
  for SECTION_KIND in "_CONST_","_CALIB_","_CARTO_","_CONFIG_DATA_" do
    foreach app in APPLICATIONS do
%      *(.OS_APP_% !app::NAME %_SEC% !SECTION_KIND !DATA_SIZE %)
%
    end foreach
  end for
 end for
%
    }
    
    .ctors : {}
    .dtors : {}
    extab : {}
    extabindex : {}
 
 __PROGCONST_SECTION_STOP = ALIGN(32) - 1 ;
 
  } > internal_flash

  GROUP : {
    .__uninitialized_intc_handlertable ALIGN(2048) : {}
    .data   : {}
    .sdata  : {}
    .sbss   : {}
    .sdata2 : {}
    .sbss2  : {}
    .bss    : {}
    .osVar (DATA) : { *(.osVar) }
    .osVarNoInit (BSS) : { *(.osVarNoInit) }
%
foreach proc in PROCESSES do
%    .% !proc::KIND %_% !proc::NAME %_SEC_VAR ALIGN(32) : {
      __SEG_START_% !proc::KIND %_% !proc::NAME %_VAR_RGN = .;
/* Initialized variables section of % !proc::KIND % % !proc::NAME % */
%
  for DATA_SIZE in "32BIT","16BIT","8BIT","BOOLEAN","UNSPECIFIED" do
    for SECTION_KIND in "_NOINIT_","_POWER_ON_INIT_","_FAST_","_" do
%      *(.% !proc::KIND %_% !proc::NAME %_SEC_VAR% !SECTION_KIND !DATA_SIZE %)
%
    end for
  end for
%/* Uninitialized variables section of % !proc::KIND % % !proc::NAME % */
%  for DATA_SIZE in "32BIT","16BIT","8BIT","BOOLEAN","UNSPECIFIED" do
    for SECTION_KIND in "_NOINIT_","_POWER_ON_INIT_","_FAST_","_" do
%       *(.% !proc::KIND %_% !proc::NAME %_noInit_SEC_VAR% !SECTION_KIND !DATA_SIZE %)
%
    end for
  end for
%      __SEG_END_% !proc::KIND %_% !proc::NAME %_VAR_RGN = ALIGN(32) - 1;
    }
%
end foreach
foreach proc in PROCESSES do
%/* Section of stack of % !proc::KIND % % !proc::NAME %  */
    .% !proc::KIND %_% !proc::NAME %_SEC_STACK ALIGN(32) : {
      __SEG_START_% !proc::KIND %_% !proc::NAME %_STACK_RGN = .;
      * (.% !proc::KIND %_% !proc::NAME %Stack)
      __SEG_END_% !proc::KIND %_% !proc::NAME %_STACK_RGN = ALIGN(32) - 1;
    }
%
end foreach
% /* os application vars */
%
foreach app in APPLICATIONS do
%
/* Section of OS Application vars of % !app::NAME % */
    .OS_APP_% !app::NAME %_SEC_ALL_VARS ALIGN(32) : {
      __SEG_START_OS_APP_% !app::NAME %_VAR_RGN = .;
/* Initialized variables section of OS_APP % !app::NAME % */
%
  for DATA_SIZE in "32BIT","16BIT","8BIT","BOOLEAN","UNSPECIFIED" do
    for SECTION_KIND in "_NOINIT_","_POWER_ON_INIT_","_FAST_","_" do
%    *(.OS_APP_% !app::NAME %_SEC_VAR% !SECTION_KIND !DATA_SIZE %)
%
    end for
  end for
%
      __SEG_END_OS_APP_% !app::NAME %_VAR_RGN = ALIGN(32) - 1;
    }
%
end foreach
%  } > internal_ram
}

/* Freescale CodeWarrior compiler address designations */
_stack_addr = ADDR(stack)+SIZEOF(stack);
_stack_end  = ADDR(stack);
_heap_addr  = ADDR(heap);
_heap_end   = ADDR(heap)+SIZEOF(heap);

_stack_addr_p1 = ADDR(stack_p1)+SIZEOF(stack_p1);
_stack_end_p1  = ADDR(stack_p1);
_heap_addr_p1  = ADDR(heap_p1);
_heap_end_p1   = ADDR(heap_p1)+SIZEOF(heap_p1);

/* Exceptions Handlers Location (used in Exceptions.c for e200z1 IVPR initialization)*/
EXCEPTION_HANDLERS    = ADDR(exception_handlers_p0);
EXCEPTION_HANDLERS_P1 = ADDR(exception_handlers_p1);

/* L2 SRAM Location (used for L2 SRAM initialization) */
L2SRAM_LOCATION = 0x40000000;

