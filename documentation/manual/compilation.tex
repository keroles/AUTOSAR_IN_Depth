%!TEX root = ./main.tex

\chapter{System generation and compilation}

\lettrine{T}rampoline is a static operating system. This means all the objects (tasks, ISR, ...) are known at compile time. This way, an application is made of tasks' code and ISRs' code, application data, and statically initialized descriptor for each object the operating system manages. A system generation tool, like \goil, generates these descriptors in C files from an application configuration described in OIL or in XML. After that the Trampoline source code, the generated files and the application source code are compiled and linked together to produce an executable file as shown in figure \ref{fig:buildtrampoline}.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=4.3in]{pictures/buildProcess.pdf} 
   \caption{\textbf{Build process of an application with Trampoline.} Starting from the left, the .c and .h corresponding to the application description given in OIL (or XML) are generated by \goil\ (or another system generation tool, for instance an Autosar compliant one) and compiled using a C compiler. Trampoline source files are compiled too and include .h from the description for configuration purpose (see section \ref{sec:configmacros}). Application files are compiled and include .h files from Trampoline. All the object files are then linked together using an optional link script generated by \goil\ or provided with the application.}\label{fig:buildtrampoline}
\end{figure}

\section{The generated files}
\label{sec:generatedfiles}

The following files are generated by \goil\ from the OIL file or should be generated if you use a different system configuration tool. More information may be found in part \ref{part:goil}.

\rowcolors{1}{white}{light-gray}
\begin{longtable}[c]{l|p{4in}}
{\bf File name} & {\bf Usage} \\

\hline

tpl_app_define.h\index{tpl_app_define.h} & This file contains all the configuration macros (see section \ref{sec:configmacros}) and is included in all the Trampoline files to trigger conditional compilation. \goil\ generates this file using the \file{tpl_app_define_h.goilTemplate} template file.\\

tpl_app_config.h\index{tpl_app_config.h} & This file contains the declarations of the constants and functions required by the OSEK and Autosar standard (like OSMAXALLOWEDVALUE_x, OSTICKSPERBASE_x or OSMINCYCLE_x constants for counter x). \goil\ generates this file using the \file{tpl_app_config_h.goilTemplate} template file.\\

tpl_app_config.c\index{tpl_app_config.c} & This file contains the definitions of the constants and functions required by the OSEK and Autosar standard and the definitions of object descriptors used by Trampoline (see section \ref{sec:structs}) \goil\ generates this file using the \file{tpl_app_config_c.goilTemplate} template file.\\

tpl_app_custom_types.h\index{tpl_app_custom_types.h} & Some data types used by Trampoline are not statically defined. They are generated to fit size or performance criterions. For instance, the type used for a TaskType may be a byte if there is less than 256 tasks in the system and a word otherwise. This file defined these data types.\\

tpl_service_ids.h\index{tpl_service_ids.h} & This file is generated only if Trampoline is compiled with service calls implemented using a system call. It contains all the identifiers of the services used by the application according to the configuration. \goil\ generates this file using the \file{tpl_service_ids_h.goilTemplate} template file.\\

tpl_dispatch_table.c\index{tpl_dispatch_table.c} & This file is generated only if Trampoline is compiled with service calls implemented using a system call. It contains the dispatch table definition. See section \ref{sec:dispatchtable}. \goil\ generates this file using the \file{tpl_dispatch_table_c.goilTemplate} template file.\\

tpl_invoque.S\index{tpl_invoque.S} & This file is generated only if Trampoline is compiled with service calls implemented using a system call. It contains the API functions for system services. See section \ref{sec:invoque}. The extension (here .S) may change according to the assembler used. \goil\ generates this file using the \file{tpl_invoque.goilTemplate} and \file{service_call.goilTemplate} template files.\\

MemMap.h\index{MemMap.h} & This file is generated only if memory mapping is enabled. It contains macros for compiler abstraction memory mapping of functions and data as defined in the Autosar standard \cite{autosar31memorymapping}. \goil\ generates this file using the \file{MemMap_h.goilTemplate} template file.\\

Compiler.h\index{Compiler.h} & This file is generated only if memory mapping is enabled. It contains macros for the compiler abstraction of functions and pointer qualifier as defined in the Autosar standard \cite{autosar31compilerabstraction}. \goil\ generates this file using the \file{Compiler_h.goilTemplate} template file.\\

Compiler_Cfg.h\index{Compiler_Cfg.h} & This file is generated only if memory mapping is enabled. It contains macros for the compiler abstraction configuration as defined in the Autosar standard \cite{autosar31compilerabstraction}. \goil\ generates this file using the \file{Compiler_Cfg_h.goilTemplate} template file.\\

script.ld\index{script.ld} & This file is generated only if memory mapping is enabled. It contains a link script to map the executable in the target memory. \goil\ generates this file using the \file{script.goilTemplate} template file.\\

\end{longtable}

The following sections give details about the content of these files.

\section{The Configuration Macros}
\label{sec:configmacros}

Trampoline can be compiled with various options. These options are controlled by setting the appropriate preprocessor configuration macros%
\index{Configuration macros}.
These macros are usually set by \goil
using the template found in \file{tpl_app_define_h.goilTemplate} file to produce the \file{tpl_app_define.h}\index{tpl_app_define.h} file that is included by the files of Trampoline. However, a different generation tool may be used and it should comply to the specification presented in the following tables. When Trampoline is compiled, the coherency and consistency of the configuration macros are checked, by using the preprocessor macros located in the \file{tpl_config_check.h} file, to ensure they correspond to a supported configuration.

3 kinds of configuration macros are used: boolean macros, numerical macros, symbol macros and string macros. Boolean macros may take 2 values: \YES\ or \NO. All macros should be defined, Trampoline does not use the \lstinline[language=C]{#ifdef} or \lstinline[language=C]{#ifndef} scheme to limit the occurrences of unwanted misconfigurations except to prevent multiple inclusions of the same header file.

\subsection{Number of objects macros}

These macros gives the number of objects of each kind (tasks, ISRs, resources, \ldots) and other values. They are used in Trampoline to check the validity of the various identifiers and to define tables of the corresponding size.
 
\rowcolors{1}{white}{light-gray}
\begin{longtable}[c]{l|l|p{3.5in}}
{\bf Macro}&{\bf Kind}&{\bf Effect}\\
\hline
\idxconfflag{PRIO_LEVEL_COUNT} &  Integer & The number of priority levels used in the system.\\
\idxconfflag{TASK_COUNT} & Integer & The number of tasks (basic and extended) used in the system.\\
\idxconfflag{EXTENDED_TASK_COUNT} & Integer & The number of extended tasks used in the system.\\
\idxconfflag{ISR_COUNT} & Integer & The number of ISR category 2 used in the system.\\
\idxconfflag{ALARM_COUNT} & Integer & The number of alarms used in the system.\\
\idxconfflag{RESOURCE_COUNT} & Integer & The number of resources used in the system.\\
\idxconfflag{SEND_MESSAGE_COUNT} & Integer & The number of send messages used in the system.\\
\idxconfflag{RECEIVE_MESSAGE_COUNT} & Integer & The number of receive messages used in the system.\\
\idxconfflag{SCHEDTABLE_COUNT} & Integer & The number of schedule tables used in the system. This macros is only used when \cmacro{WITH_AUTOSAR} is set to \YES.\\
\idxconfflag{COUNTER_COUNT} & Integer & The number of counters used in the system. This macros is only used when \cmacro{WITH_AUTOSAR} is set to \YES.\\
\idxconfflag{APP_COUNT} & Integer & The number of OS applications used in the system. This macros is only used when \cmacro{WITH_AUTOSAR} is set to \YES.\\
\idxconfflag{TRUSTED_FCT_COUNT} & Integer & The number of trusted functions used in the system. This macros is only used when \cmacro{WITH_AUTOSAR} is set to \YES.\\
\idxconfflag{RES_SCHEDULER_PRIORITY} & Integer & The priority of the \constant{RES_SCHEDULER} resource. This should be equal to the highest priority among the tasks.\\
\end{longtable}

\subsection{Error Handling Macros}
\label{sec:errorhook}

Error handling related macros are used to configure what kind of error Trampoline checks and what extra processing is done when an error is encountered.

\rowcolors{1}{white}{light-gray}
\begin{longtable}[c]{l|l|p{3.3in}}
{\bf Macro} & {\bf Kind} & {\bf Effect}\\
\hline
\idxconfflag{WITH_OS_EXTENDED} & Bool & When set to \YES, Trampoline system services perform error checking on their arguments. \cmacro{WITH_OS_EXTENDED} is set to \YES\ with a \oilattr{STATUS} = \constant{EXTENDED} and is set to \NO\ with a \oilattr{STATUS} = \constant{BASIC} in the OIL OS object.\\
\idxconfflag{WITH_ERROR_HOOK} & Bool & When set to \YES, the \cfunction{ErrorHook()} function is called if an error occurs. \cmacro{WITH_ERROR_HOOK} is set to \YES/\NO\ with a \cmacro{ERRORHOOK} = \TRUE/\FALSE\ in the OIL OS object.\\
\idxconfflag{WITH_USEGETSERVICEID} & Bool & When set to \YES, Trampoline system services store the id of the current service. This id may be retrieved in the \cfunction{ErrorHook()} function by using the \cfunction{OSErrorGetServiceId()} macro. \cmacro{WITH_USEGETSERVICEID} is set to \YES/\NO\ with a \oilattr{USEGETSERVICEID} = \TRUE/\FALSE\ in the OIL OS object.\\
\idxconfflag{WITH_USEPARAMETERACCESS} & Bool & When set to \YES, Trampoline system services store the arguments of the current service. These arguments may be retrieved in the \cfunction{ErrorHook()} function by using the ad-hoc access macros (see \cmacro{WITH_USEGETSERVICEID} above). \cmacro{WITH_USEPARAMETERACCESS} is set to \YES/\NO\ with a \oilattr{USEPARAMETERACCESS} = \TRUE/\FALSE\ in the OIL OS object.\\
\idxconfflag{WITH_COM_ERROR_HOOK} & Bool & When set to \YES, the communication error hook is called when error occurs in the communication sub-system. This macro is only available when \cmacro{WITH_COM} is set to \YES.\\
\idxconfflag{WITH_COM_USEGETSERVICEID} & Bool & When set to \YES, Trampoline/COM system services store the id of the current service. This id may be retrieved in the \cfunction{COMErrorHook()} function by using the \cfunction{COMErrorGetServiceId()} macro. \cmacro{WITH_COM_USEGETSERVICEID} is set to \YES/\NO\ with a \oilattr{COMUSEGETSERVICEID} = \TRUE/\FALSE\ in the OIL COM object.\\
\idxconfflag{WITH_COM_USEPARAMETERACCESS} & Bool & When set to \YES, Trampoline/COM system services store the arguments of the current service. These arguments may be retrieved in the \cfunction{COMErrorHook()} function by using the ad-hoc access macros (see \ref{sec:comerrorhook}). \cmacro{WITH_COM_USEPARAMETERACCESS} is set to \YES/\NO with a \oilattr{COMUSEPARAMETERACCESS} = \TRUE/\FALSE\ in the OIL COM object.\\
\idxconfflag{WITH_COM_EXTENDED} & Bool & When set to \YES, Trampoline/COM system services perform error checking on their arguments. \cmacro{WITH_COM_EXTENDED} is set to \YES\ with a \oilattr{COMSTATUS} = \EXTENDED\ and is set to \NO\ with a \oilattr{COMSTATUS} = \BASIC\ in the OIL COM object.\\
\end{longtable}

\subsection{Protection Macros}
\label{sec:protectionhook}

Protection macros deal with protection facilities provided by the \autosar\ standard.

\rowcolors{1}{white}{light-gray}
\begin{longtable}[c]{l|l|p{3.6in}}
{\bf Macro} & {\bf Kind} & {\bf Effect}\\
\hline
\idxconfflag{WITH_MEMORY_PROTECTION} & Bool & When set to \YES, Trampoline enables the memory protection facility. This is only supported on some ports (MPC5510 and ARM9 at time of writing). Memory protection requires the memory mapping and the use of system call. \cmacro{WITH_MEMORY_PROTECTION} is set to \YES/\NO\ with the \oilattr{MEMORY_PROTECTION} attribute of \oilattr{MEMMAP} object (see \ref{sec:memmap}) set to \TRUE/\FALSE.\\
\idxconfflag{WITH_TIMING_PROTECTION} & Bool & When set to \YES, Trampoline enables the timing protection facility. \cmacro{WITH_TIMING_PROTECTION} is set to \YES if the \oilattr{AUTOSAR_SC} is 2 or 4 (see \ref{sec:autosarsc}) and a least one of the objects specifies a timing protection related attribute in the OIL file.\\
\idxconfflag{WITH_PROTECTION_HOOK} &  Bool & When set to \YES, Trampoline calls the \cfunction{ProtectionHook()} with the appropriate argument when a protection fault occurs. \cmacro{WITH_PROTECTION_HOOK} is set to \YES with a \oilattr{PROTECTIONHOOK} = \TRUE in the OIL OS object.\\
\idxconfflag{WITH_STACK_MONITORING} & Bool & When set to \YES, Trampoline enables the stack monitoring. Each time a context switch occurs, the stack pointer is checked. If the stack pointer is outside the stack zone of the process, a fault occurs. \cmacro{WITH_STACK_MONITORING} is set to \YES with a \oilattr{STACKMONITORING} = TRUE in the oil OS object.\\
\end{longtable}

\subsection{Hook call macros}

Hook call macros control whether a hook is called or not.

\rowcolors{1}{white}{light-gray}
\begin{longtable}[c]{l|l|p{3.71in}}
{\bf Macro} & {\bf Kind} & {\bf Effect}\\
\hline
\idxconfflag{WITH_ERROR_HOOK} & Bool & see \ref{sec:errorhook}\\
\idxconfflag{WITH_PRE_TASK_HOOK} & Bool & When set to \YES, each time a task is scheduled, the function \cfunction{PreTaskHook()} is called. \cmacro{WITH_PRE_TASK_HOOK} is set to \YES/\NO\ with a \oilattr{PRETASKHOOK} = \TRUE/\FALSE\
  in the OIL OS object.\\
\idxconfflag{WITH_POST_TASK_HOOK} & Bool & When set to \YES, each time a task is descheduled, the function \cfunction{PostTaskHook()} is called. \cmacro{WITH_POST_TASK_HOOK} is set to \YES/\NO\ with a \oilattr{POSTTASKHOOK} = \TRUE/\FALSE\
  in the OIL OS object.\\
\idxconfflag{WITH_STARTUP_HOOK} & Bool & When set to \YES, the function \cfunction{StartupHook()} is called within the \api{StartOS} service.  \cmacro{WITH_STARTUP_HOOK} is set to \YES/\NO\ with a \oilattr{STARTUPHOOK} = \TRUE/\FALSE\ in the OIL OS object.\\
\idxconfflag{WITH_SHUTDOWN_HOOK} & Bool & When set to \YES, the function \cfunction{ShutdownHook()} is called within the \api{ShutdownOS} service. \cmacro{WITH_SHUTDOWN_HOOK} is set to \YES/\NO\ with a \oilattr{SHUTDOWNHOOK} = \TRUE/\FALSE\ in the OIL OS object.\\
\idxconfflag{WITH_PROTECTION_HOOK} & Bool & see \ref{sec:protectionhook}\\
\end{longtable}

\subsection{Miscellaneous macros}

Here are the other available macros:

\rowcolors{1}{white}{light-gray}
\begin{longtable}[c]{l|l|p{3.25in}}
{\bf Macro} & {\bf Kind} & {\bf Effect}\\
\hline
\idxconfflag{WITH_USERESSCHEDULER} & Bool & When set to \YES, the \constant{RES_SCHEDULER} resource is used by at least one process. \cmacro{WITH_USERESSCHEDULER} is set to \YES/\NO\ with a \oilattr{USERESSCHEDULER} = \TRUE/\FALSE\ in the OIL OS object.\\
\idxconfflag{WITH_SYSTEM_CALL} & Bool & When set to \YES, services are called by the mean of a system call, also known as a software interrupt (see section \ref{sec:systemcall}). \cmacro{WITH_SYSTEM_CALL} is set to \YES/\NO\ according to the target architecture and requires a memory mapping\\
\idxconfflag{WITH_MEMMAP} & Bool & When set to \YES, a memory mapping is used. A \file{MemMap.h} files giving the available memory segments is included and should be generated or provided by the user. \goil\ generates such a file.
  \cmacro{WITH_MEMMAP} is set to \YES/\NO\ with a \oilattr{MEMMAP} = \TRUE/\FALSE\ in the OIL OS object.\\
\idxconfflag{WITH_COMPILER_SETTINGS} & Bool & When set to \YES, the compiler dependent macros are used. \file{Compiler.h} and \file {Compiler_Cfg.h} files are includes and should be generated or provided by the user. \goil\ generates these  files if \oilattr{MEMMAP} is \TRUE\ and the \oilattr{COMPILER} sub-attribute is set.\\
\idxconfflag{WITH_AUTOSAR} & Bool & When set to \YES, Trampoline contains additional system services, code and declarations related to the \autosar\ standard. For instance, the counter descriptor includes the counter type (hardware or software).   \cmacro{WITH_AUTOSAR} is set to \YES/\NO\ when at least one \autosar\ object is present in the system configuration (OIL file for instance).\\
\idxconfflag{TRAMPOLINE_BASE_PATH} & String & The path to Trampoline root directory.\\
\idxconfflag{AUTOSAR_SC} & Integer & The \autosar\ scalability class\index{Scalability class} ranging from 0 to 4. 0 means OSEK\\
\idxconfflag{WITH_OSAPPLICATION} & Bool & When set to \YES, OS Application\index{OS Application} are used.\\
\idxconfflag{WITH_TRACE} & Bool & When set to \YES, the tracing of the operating system is enabled.\\
\idxconfflag{TRACE_TASK} & Bool & When set to \YES, task (de)scheduling events are traced. Only available if \cmacro{WITH_TRACE} is set to \YES.\\
\idxconfflag{TRACE_ISR} & Bool & When set to \YES, ISR category 2 (de)scheduling events are traced. Only available if \cmacro{WITH_TRACE} is set to \YES.\\
\idxconfflag{TRACE_RES} & Bool & When set to \YES, resources get and release are traced. Only available if \cmacro{WITH_TRACE} is set to \YES.\\
\idxconfflag{TRACE_ALARM} & Bool & When set to \YES, alarm activities are traced. Only available if \cmacro{WITH_TRACE} is set to \YES.\\
\idxconfflag{TRACE_U_EVENT} & Bool & When set to \YES, user events are traced. Only available if \cmacro{WITH_TRACE} is set to \YES.\\
\idxconfflag{TRACE_FORMAT} & Symbol & Trace format. A function named \cfunction{tpl_trace_format_\toreplace{\cmacro{TRACE_FORMAT}}} is expected. Only available if \cmacro{WITH_TRACE} is set to \YES.\\
\idxconfflag{TRACE_FILE} & String & File name where the trace is stored. Usable on Posix target only. Only available if \cmacro{WITH_TRACE} is set to \YES.\\
\idxconfflag{WITH_IT_TABLE} & Bool & When set to \YES, the external interrupts are dispatched using a table of fonction pointers.\\
\idxconfflag{WITH_COM} & Bool & When set to \YES, internal communication is used.\\
\idxconfflag{TPL_COMTIMEBASE} & Integer & The \oilattr{COMTIMEBASE} expressed in nanoseconds.\\
\idxconfflag{WITH_COM_STARTCOMEXTENSION} & Bool & When set to \YES, the communication extension function is called.\\
\end{longtable}

\section{Application configuration}

The application configuration is generated by \goil\ using the template found in \file{tpl_app_config_h.goilTemplate} file and \file{tpl_app_config_c.goilTemplate} file to produce the \file{tpl_app_define.h}\index{tpl_app_define.h} and \file{tpl_app_define.c}\index{tpl_app_define.c} files.

\subsection{Counter related constants declaration}

The \file{tpl_app_config.h} files contains the counters related constants: those of the SystemCounter\footnote{the default counter of an OSEK operating system} and those of the counters defined by the user. The SystemCounter constants are located in the generated files because the SystemCounter default attributes may be modified by the user in the OIL or XML file. The constants of a user defined counter are declared as follow:

\begin{lstlisting}[language=C]
extern CONST(tpl_tick, OS_CONST) OSTICKSPERBASE_<counter name>;
extern CONST(tpl_tick, OS_CONST) OSMAXALLOWEDVALUE_<counter name>;
extern CONST(tpl_tick, OS_CONST) OSMINCYCLE_<counter name>;
\end{lstlisting}

Where \toreplace{counter name} is obviously the name given to the counter in the confguration. For the SystemCounter, the following constants are declared:

%\begin{lstlisting}[language=C]
%extern CONST(tpl_tick, OS_CONST) OSTICKSPERBASE;
%extern CONST(tpl_tick, OS_CONST) OSMAXALLOWEDVALUE;
%extern CONST(tpl_tick, OS_CONST) OSMINCYCLE;
%\end{lstlisting}

\subsection{Events definition}

The \file{tpl_app_config.c} file should contain the event mask definitions. For each event defined in the configuration, the following lines should appear:

\begin{lstlisting}[language=C]
#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define <event name>_mask <mask value>
CONST(EventMaskType, AUTOMATIC) <event name> = <event name>_mask;

#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
\end{lstlisting}

Where \toreplace{event name} is the name given to the event in the configuration and \toreplace{mask value} is the value set by the user in the configuration or, when set to AUTO, the value computed by the generation tool.

\subsection{Standard resources definition}

Standard resources need the definition of an identifier used to reference the resource in a system service (\cfunction{GetResource()} and \cfunction{ReleaseResource()}) and an instance of a \ctype{tpl_resource} structure (see \ref{sec:structtplresource}). This is done with the following definitions:

\begin{lstlisting}[language=C]
#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define <resource name>_id <resource id>
CONST(ResourceType, AUTOMATIC) <resource name> = <resource name>_id;

#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_resource, OS_VAR) <resource name>_rez_desc = {
  /* ceiling priority of the resource */  <resource priority>,
  /* owner previous priority          */  0,
  /* owner of the resource            */  INVALID_PROC_ID,
#if WITH_OSAPPLICATION == YES
  /* OS Application id                */  <resource application id>,
#endif    
  /* next resource in the list        */  NULL
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
\end{lstlisting}

Where \toreplace{resource name} is the name given to the resource in the configuration, \toreplace{resource priority} is the priority of the resource that is computed by the generation tool and is the maximum priority of the processes that use the resource and \toreplace{resource application id} is the identifier of the OS Application the resource belongs to. Since this field is protected by \constant{WITH_OSAPPLICATION}, it may be leaved empty when no OS Application is used.

\toreplace{resource id} ranges from 0 to the number of standard resources minus 1. Once every standard resource descriptor is defined, a table gathering pointers to the resource descriptors and indexed by the resource id has to be defined. This table is used by system services to get the resource descriptor from the resource id. Suppose 3 standard resource, \var{motor1}, \var{motor2} and \var{dac} has been defined and RES_SCHEDULER is used, the table should be as follow:

\begin{lstlisting}[language=C]
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2VAR(tpl_resource, AUTOMATIC, OS_APPL_DATA)
tpl_resource_table[RESOURCE_COUNT] = {
  &motor1_rez_desc,
  &motor2_rez_desc,
  &dac_rez_desc,
  &res_sched_rez_desc  
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
\end{lstlisting}

\var{\&res_sched_rez_desc}, the pointer to the resource descriptor of RES_SCHEDULER should always be the last element of the table. If RES_SCHEDULER is not used, simply remove it from the table.

\subsection{Tasks definition}

Each task needs an identifier to reference a task un a system service (\cfunction{ActivateTask()}, \cfunction{ChainTask()}, \cfunction{GetTaskState()}, \cfunction{SetEvent()} and \cfunction{GetEvent()}) and the declaration of the task function. The following definitions should appear for each task:

\begin{lstlisting}[language=C]
#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define <task name>_id <task id>
CONST(TaskType, AUTOMATIC) <task name> = <task name>_id;

#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define APP_Task_<task name>_START_SEC_CODE
#include "tpl_memmap.h"

FUNC(void, OS_APPL_CODE) <task name>_function(void);

#define APP_Task_<task name>_STOP_SEC_CODE
#include "tpl_memmap.h"
\end{lstlisting}

Where \toreplace{task name} is the name given to the task in the configuration and \toreplace{task id} is the identifier of the task computed by the system generation tool. Task ids should range from 0 to the number of tasks minus 1. In addition, id allocation must start with extended tasks first and basic task after. In addition an instance of the static task descriptor must be provided:

\begin{lstlisting}[language=C]
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONST(tpl_proc_static, OS_CONST) <task name>_task_stat_desc = {
  /* context                  */  <task name>_CONTEXT,
  /* stack                    */  <task name>_STACK,
  /* entry point (function)   */  <task name>_function,
  /* internal ressource       */  <internal resource>,
  /* task id                  */  <task name>_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  <application>,
#endif
  /* task base priority       */  <task priority>,
  /* max activation count     */  <task activation>,
  /* task type                */  <task type>
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  ,<timing protection>
#endif
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
\end{lstlisting}

Where \toreplace{task name} is the name given to the task in the configuration. \toreplace{internal resource} mays be one of the following:

\begin{itemize}
\item a pointer to the internal resource descriptor (see \ref{sec:internalresource}) if an internal resource has been defined in the configuration;
\item a pointer to the scheduler internal resource if the task has been defined as non-preemptable in the configuration;
\item NULL if none of the above cases apply.
\end{itemize}

\toreplace{application} is the id of the OS Application the task belongs to when OS Application are used or, when they are not used, nothing at all. \toreplace{task priority} is the priority of the task as computed by the \sysgen. \toreplace{task activation} is the maximum number of task activation allowed as defined in the configuration. \toreplace{task type} may be \EXTENDED\ or \BASIC. \toreplace{timing protection} is a pointer to the timing protection descriptor or NULL if no timing protection is defined for the task.

Also an instance of the dynamic task descriptor must be provided:

\begin{lstlisting}[language=C]
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_proc, OS_VAR) <task name>_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  <trusted count>,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  <task priority>,
  /* task state                     */  <task state>
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
\end{lstlisting}

Where \toreplace{task name} is the name given to the task in the configuration. \toreplace{trusted count} is 0 if the task belongs to a non trusted OS Application and 1 if the tasks belongs to a trusted OS Application. \toreplace{task priority} is the priority of the task as computed by the \sysgen. \toreplace{task state} is the initial state of the task and must be set to AUTOSTART or SUSPENDED.

If the task is an EXTENDED one, an event mask descriptor is added:

%\lstdefinelanguage[trampconf]{C}{morecomment=[s][\color{red}]{<}{>}}

\begin{lstlisting}[language=C]
VAR(tpl_task_events, OS_VAR) <task name>_task_evts = {
  /* event set  */ 0,
  /* event wait */ 0
};
\end{lstlisting}

Where \toreplace{task name} is the name given to the task in the configuration.

